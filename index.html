<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WorldEdit Converter beta</title>
    <link rel="icon" href="assets/favicon.png" type="image/png">
    <meta name="description"
        content="Minecraft Schematic„Éï„Ç°„Ç§„É´(.nbt, .schem)„ÄÅMinetest WorldEdit(.we)„ÄÅ3D„É¢„Éá„É´(.obj, .stl)„ÇíMulticraft„ÅÆWorldEdit„Ç≥„Éû„É≥„Éâ„Å´Â§âÊèõ„Åô„Çã„ÉÑ„Éº„É´">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="WorldEdit Converter beta">
    <meta property="og:description"
        content="Minecraft Schematic„Éï„Ç°„Ç§„É´(.nbt, .schem)„ÄÅMinetest WorldEdit(.we)„ÄÅ3D„É¢„Éá„É´(.obj, .stl)„ÇíMulticraft„ÅÆWorldEdit„Ç≥„Éû„É≥„Éâ„Å´Â§âÊèõ„Åô„Çã„ÉÑ„Éº„É´">
    <meta property="og:image"
        content="https://raw.githubusercontent.com/dark-multicraft/scheme-convertor/main/assets/ogp.png">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="WorldEdit Converter beta">
    <meta name="twitter:description"
        content="Minecraft Schematic„Éï„Ç°„Ç§„É´(.nbt, .schem)„ÄÅMinetest WorldEdit(.we)„ÄÅ3D„É¢„Éá„É´(.obj, .stl)„ÇíMulticraft„ÅÆWorldEdit„Ç≥„Éû„É≥„Éâ„Å´Â§âÊèõ„Åô„Çã„ÉÑ„Éº„É´">
    <meta name="twitter:image"
        content="https://raw.githubusercontent.com/dark-multicraft/scheme-convertor/main/assets/ogp.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="js/multicraft_items.js"></script>
    <!-- Three.js r125 for 3D model loading (older version that supports global namespace) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.125.2/examples/js/loaders/STLLoader.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #f5f5f5;
            color: #222;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            height: 100vh;
            gap: 0;
            background: #f5f5f5;
        }

        .panel {
            background: #fff;
            padding: 20px 24px;
            overflow-y: auto;
            border-left: 1px solid #e8e8e8;
        }

        .panel:first-child {
            border-left: none;
        }

        .right-panel {
            display: flex;
            flex-direction: column;
        }

        .right-panel .log-panel {
            flex: 1;
            min-height: 100px;
        }

        .action-section {
            display: flex;
            gap: 10px;
            padding-top: 16px;
            margin-top: auto;
            border-top: 1px solid #eee;
        }

        h1 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 18px;
            color: #111;
            letter-spacing: -0.01em;
        }

        h2 {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        /* Left Panel */
        .drop-zone {
            border: 2px dashed #d0d0d0;
            border-radius: 6px;
            padding: 28px 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.15s;
            margin-bottom: 20px;
            background: #fafafa;
        }

        .drop-zone:hover,
        .drop-zone.dragover {
            border-color: #888;
            background: #f0f0f0;
        }

        .drop-zone p {
            color: #555;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .drop-zone input {
            display: none;
        }

        .setting-group {
            margin-bottom: 16px;
        }

        .setting-group label {
            display: block;
            color: #555;
            font-size: 0.85rem;
            margin-bottom: 5px;
        }

        .setting-group input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d8d8d8;
            border-radius: 4px;
            font-size: 0.95rem;
            background: #fff;
        }

        .setting-group input:focus {
            outline: none;
            border-color: #888;
        }

        .setting-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d8d8d8;
            border-radius: 4px;
            font-size: 0.95rem;
            background: #fff;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23666' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 16px;
            padding-right: 36px;
        }

        .setting-group select:focus {
            outline: none;
            border-color: #888;
        }

        .setting-group select:hover {
            border-color: #aaa;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 0.9rem;
            border-bottom: 1px solid #eee;
        }

        .status-label {
            color: #777;
        }

        .status-value {
            color: #222;
            font-weight: 500;
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 0.85rem;
        }

        .progress-bar {
            width: 100%;
            height: 2px;
            background: #e5e5e5;
            border-radius: 1px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #444;
            width: 0%;
            transition: width 0.2s;
        }

        /* Conditional settings sections */
        .settings-3d {
            display: none;
        }

        .settings-3d.visible {
            display: block;
        }

        .settings-nbt {
            display: none;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        .settings-nbt.visible {
            display: flex;
            flex: 1;
            overflow-y: auto;
        }

        .settings-nbt .unknown-list {
            flex: 0 1 auto;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 8px;
            background: #fafafa;
            min-height: 50px;
            max-height: 400px;
        }


        /* Unknown Blocks Modal */
        .unknown-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 900;
            justify-content: center;
            align-items: center;
        }

        .unknown-modal.active {
            display: flex;
        }

        .unknown-modal-content {
            background: #fff;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .unknown-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: #f8f8f8;
            border-bottom: 1px solid #e0e0e0;
        }

        .unknown-modal-header h3 {
            font-size: 1rem;
            font-weight: 600;
            color: #333;
            margin: 0;
        }

        .unknown-modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #888;
            cursor: pointer;
            padding: 0 4px;
        }

        .unknown-modal-close:hover {
            color: #333;
        }

        .unknown-modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
        }

        .unknown-modal-hint {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 16px;
            padding: 10px 12px;
            background: #f5f5f5;
            border-radius: 4px;
        }

        .unknown-modal-footer {
            padding: 16px 20px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .unknown-modal-footer button {
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.15s;
        }

        .unknown-modal-footer .btn-primary {
            background: #222;
            color: #fff;
            border: none;
        }

        .unknown-modal-footer .btn-primary:hover {
            background: #333;
        }

        .unknown-modal-footer .btn-secondary {
            background: #fff;
            color: #333;
            border: 1px solid #ccc;
        }

        .unknown-modal-footer .btn-secondary:hover {
            background: #f5f5f5;
        }

        /* Center Panel */
        .center-panel {
            display: flex;
            flex-direction: column;
        }

        .unknown-header {
            padding-bottom: 14px;
            border-bottom: 1px solid #eee;
            margin-bottom: 14px;
        }

        .unknown-hint {
            font-size: 0.85rem;
            color: #888;
            margin-top: 6px;
        }

        .unknown-actions {
            display: inline-flex;
            gap: 4px;
            margin-left: auto;
        }

        .unknown-action-btn {
            background: none;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .unknown-action-btn:hover {
            background: #f0f0f0;
            border-color: #aaa;
        }

        .settings-group-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Import Modal */
        .import-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .import-modal.active {
            display: flex;
        }

        .import-modal-content {
            background: #fff;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .import-modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .import-modal-title {
            font-weight: 600;
            font-size: 1rem;
        }

        .import-modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }

        .import-modal-body {
            padding: 16px 20px;
            flex: 1;
            overflow-y: auto;
        }

        .import-modal-hint {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .import-modal-hint code {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 0.8rem;
        }

        #importTextarea {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 0.85rem;
            resize: vertical;
        }

        .import-modal-footer {
            padding: 16px 20px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .unknown-list {
            flex: 1;
            overflow-y: auto;
        }

        .unknown-item {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 14px;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
            align-items: center;
        }

        .unknown-name {
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 0.8rem;
            color: #333;
            word-break: break-all;
        }

        .unknown-count {
            font-size: 0.8rem;
            color: #888;
        }

        .autocomplete-wrapper {
            position: relative;
        }

        .unknown-input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #d8d8d8;
            border-radius: 4px;
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 0.85rem;
            background: #fff;
        }

        .unknown-input:focus {
            outline: none;
            border-color: #888;
        }

        .autocomplete-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #fff;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .autocomplete-list.visible {
            display: block;
        }

        .autocomplete-item {
            padding: 8px 10px;
            cursor: pointer;
            font-size: 0.85rem;
            border-bottom: 1px solid #eee;
        }

        .autocomplete-item:hover {
            background: #f0f0f0;
        }

        .autocomplete-item .item-id {
            font-family: 'SF Mono', Consolas, monospace;
            color: #333;
        }

        .autocomplete-item .item-name {
            color: #777;
            font-size: 0.75rem;
        }

        .convert-btn {
            margin-top: 16px;
            width: 100%;
            padding: 12px;
            background: #222;
            color: #fff;
            border: none;
            border-radius: 4px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.15s;
        }

        .convert-btn:hover {
            background: #333;
        }

        .convert-btn:disabled {
            background: #bbb;
            cursor: not-allowed;
        }

        /* Right Panel */
        .log-panel {
            font-family: 'SF Mono', Consolas, 'Courier New', monospace;
            font-size: 0.8rem;
            flex: 1;
            overflow-y: auto;
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 12px 14px;
            margin-bottom: 16px;
            line-height: 1.6;
        }

        .log-entry {
            padding: 2px 0;
            color: #555;
        }

        .log-entry.success {
            color: #2a8;
        }

        .log-entry.error {
            color: #d44;
        }

        .log-entry.warning {
            color: #a80;
        }

        .download-area {
            margin-top: auto;
        }

        .download-item {
            margin-bottom: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 12px 14px;
            background: #fafafa;
        }

        .download-item-header {
            font-size: 0.9rem;
            color: #444;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .download-buttons {
            display: flex;
            gap: 8px;
        }

        .download-link {
            flex: 1;
            display: block;
            background: #222;
            color: #fff;
            padding: 10px 14px;
            border-radius: 4px;
            text-decoration: none;
            font-size: 0.85rem;
            text-align: center;
            transition: background 0.15s;
        }

        .download-link:hover {
            background: #333;
        }

        .copy-btn {
            flex: 1;
            background: #555;
            color: #fff;
            padding: 10px 14px;
            border-radius: 4px;
            border: none;
            font-size: 0.85rem;
            cursor: pointer;
            transition: background 0.15s;
        }

        .copy-btn:hover {
            background: #666;
        }

        .copy-btn.copied {
            background: #3a3;
        }

        .empty-state {
            color: #999;
            font-size: 0.85rem;
            text-align: center;
            padding: 40px 20px;
        }

        /* Voxel Preview Modal */
        .preview-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
        }

        .preview-modal.active {
            display: flex;
            flex-direction: column;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .preview-title {
            color: #fff;
            font-size: 1rem;
            font-weight: 500;
        }

        .preview-info {
            color: #888;
            font-size: 0.85rem;
        }

        .preview-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0 8px;
        }

        .preview-close:hover {
            color: #f55;
        }

        .preview-canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #previewCanvas {
            width: 100%;
            height: 100%;
        }

        .preview-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 16px;
            border-radius: 8px;
        }

        .preview-controls button {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .preview-controls button:hover {
            background: #444;
        }

        .preview-hint {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #888;
            font-size: 0.75rem;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 4px;
        }

        .preview-btn {
            margin-top: 8px;
            width: 100%;
            padding: 8px;
            background: #555;
            color: #fff;
            border: none;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
        }

        .preview-btn:hover {
            background: #666;
        }

        .preview-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Command Preview */
        .command-preview {
            margin-top: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .command-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: #f5f5f5;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
        }

        .command-preview-header:hover {
            background: #eee;
        }

        .command-preview-title {
            font-size: 0.8rem;
            color: #666;
        }

        .command-preview-toggle {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 0.75rem;
            padding: 2px 6px;
        }

        .command-preview-content {
            max-height: 300px;
            overflow-y: auto;
            background: #1e1e1e;
            padding: 10px;
            font-family: monospace;
            font-size: 0.7rem;
            line-height: 1.4;
        }

        .command-preview-content.collapsed {
            display: none;
        }

        .cmd-line {
            color: #d4d4d4;
            white-space: pre;
            display: block;
        }

        .cmd-shift {
            color: #6a9955;
        }

        .cmd-set {
            color: #569cd6;
        }

        .cmd-param {
            color: #ce9178;
        }

        /* Clean UI Styles */
        .drop-zone {
            border: 1px dashed #ccc;
            border-radius: 4px;
            padding: 32px 16px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.15s, background 0.15s;
            margin-bottom: 16px;
            background: #fafafa;
        }

        .drop-zone:hover,
        .drop-zone.dragover {
            border-color: #666;
            background: #f5f5f5;
        }

        .drop-zone-icon {
            font-size: 2rem;
            color: #999;
            line-height: 1;
            margin-bottom: 8px;
        }

        .drop-zone-text {
            color: #555;
            font-size: 0.9rem;
            margin-bottom: 4px;
        }

        .drop-zone-hint {
            color: #999;
            font-size: 0.75rem;
        }

        .drop-zone input {
            display: none;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: #e8f5e9;
            border-radius: 4px;
            margin-bottom: 16px;
            font-size: 0.85rem;
        }

        .status-bar #fileName {
            color: #2e7d32;
            font-weight: 500;
        }

        .status-bar #blockCount {
            color: #666;
        }

        .settings-section {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        .settings-group-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-bottom: 10px;
            padding-top: 12px;
            border-top: 1px solid #eee;
        }

        .action-section {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .btn-primary {
            flex: 1;
            background: #222;
            color: #fff;
            border: none;
            padding: 12px 16px;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.15s;
        }

        .btn-primary:hover:not(:disabled) {
            background: #333;
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn-secondary {
            flex: 0 0 auto;
            background: #fff;
            color: #333;
            border: 1px solid #ddd;
            padding: 12px 16px;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #f5f5f5;
            border-color: #bbb;
        }

        .btn-secondary:disabled {
            color: #aaa;
            cursor: not-allowed;
        }

        .progress-section {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .progress-section .progress-bar {
            flex: 1;
            margin: 0;
        }

        .progress-label {
            font-size: 0.8rem;
            color: #666;
            min-width: 60px;
            text-align: right;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            overflow-y: hidden;
        }

        .right-panel {
            display: flex;
            flex-direction: column;
        }

        .output-tabs {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
            margin-bottom: 12px;
        }

        .output-tabs .tab {
            padding: 8px 0;
            font-size: 0.85rem;
            font-weight: 500;
            color: #333;
            border-bottom: 2px solid #333;
        }

        .log-panel {
            flex: 1;
            min-height: 200px;
        }

        .download-area {
            flex-shrink: 0;
            margin-top: auto;
        }

        /* „É¨„Çπ„Éù„É≥„Ç∑„Éñ„Éá„Ç∂„Ç§„É≥ - „Çø„Éñ„É¨„ÉÉ„Éà„Éª„Çπ„Éû„Éº„Éà„Éï„Ç©„É≥ÂØæÂøú */
        @media screen and (max-width: 1024px) {
            body {
                overflow-y: auto;
                height: auto;
                min-height: 100vh;
                min-height: -webkit-fill-available;
            }

            .container {
                grid-template-columns: 1fr;
                height: auto;
                min-height: 100vh;
                min-height: -webkit-fill-available;
            }

            .panel {
                border-left: none;
                border-bottom: 1px solid #e8e8e8;
                padding-bottom: 24px;
            }

            .left-panel {
                overflow-y: visible;
            }

            .right-panel {
                min-height: 40vh;
                padding-bottom: calc(24px + env(safe-area-inset-bottom, 0px));
            }

            .action-section {
                position: sticky;
                bottom: 0;
                background: #fff;
                padding: 12px 0;
                margin: 0 -24px;
                padding-left: 24px;
                padding-right: 24px;
                border-top: 1px solid #eee;
                z-index: 10;
            }
        }

        @media screen and (max-width: 600px) {
            .panel {
                padding: 16px;
            }

            h1 {
                font-size: 1rem;
            }

            .drop-zone {
                padding: 20px 12px;
            }

            .drop-zone-text {
                font-size: 0.85rem;
            }

            .settings-grid {
                grid-template-columns: 1fr;
            }

            .btn-primary,
            .btn-secondary {
                padding: 14px 16px;
                font-size: 1rem;
            }

            .action-section {
                flex-direction: column;
            }

            .download-item {
                padding: 12px;
            }

            .download-buttons {
                flex-direction: column;
                gap: 8px;
            }

            .download-link,
            .copy-btn {
                width: 100%;
                text-align: center;
                padding: 12px;
            }

            .unknown-item {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            /* „Éó„É¨„Éì„É•„Éº„É¢„Éº„ÉÄ„É´„Çí„Éï„É´„Çπ„ÇØ„É™„Éº„É≥„Å´ */
            .preview-modal-content {
                width: 95%;
                height: 90%;
                max-width: none;
            }

            .preview-controls {
                flex-wrap: wrap;
            }
        }

        /* „Çø„ÉÉ„ÉÅ„Éá„Éê„Ç§„ÇπÂêë„Åë„ÅÆË™øÊï¥ */
        @media (hover: none) and (pointer: coarse) {
            .drop-zone {
                padding: 24px 16px;
            }

            .btn-primary,
            .btn-secondary {
                min-height: 48px;
            }

            .setting-group input,
            .setting-group select {
                min-height: 44px;
                font-size: 16px;
                /* iOS„Åß„Ç∫„Éº„É†„ÇíÈò≤Ê≠¢ */
            }

            .unknown-input {
                min-height: 44px;
                font-size: 16px;
            }

            .autocomplete-item {
                padding: 12px 10px;
            }
        }

        /* „Ç´„Çπ„Çø„É†Â§âÊèõ„Çª„ÇØ„Ç∑„Éß„É≥ */
        .settings-custom-convert {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #eee;
        }

        .custom-convert-checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .custom-convert-checkbox-wrapper input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .custom-convert-checkbox-wrapper label {
            font-size: 0.85rem;
            color: #555;
            cursor: pointer;
        }

        .custom-convert-hint {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 10px;
        }

        .custom-convert-list {
            margin-top: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .custom-convert-entry {
            display: grid;
            grid-template-columns: 1fr auto 1fr auto;
            gap: 8px;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .custom-convert-arrow {
            color: #888;
            font-size: 0.85rem;
        }

        .custom-convert-remove-btn {
            background: none;
            border: none;
            color: #999;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px 8px;
            line-height: 1;
        }

        .custom-convert-remove-btn:hover {
            color: #d44;
        }

        .custom-convert-add-btn {
            margin-top: 8px;
            padding: 6px 12px;
            background: #fff;
            color: #333;
            border: 1px dashed #bbb;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            width: 100%;
            transition: all 0.15s;
        }

        .custom-convert-add-btn:hover {
            background: #f5f5f5;
            border-color: #888;
        }

        @media screen and (max-width: 600px) {
            .custom-convert-entry {
                grid-template-columns: 1fr auto;
                gap: 6px;
            }

            .custom-convert-arrow {
                display: none;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Left Panel -->
        <div class="panel left-panel">
            <h1>WorldEdit Converter beta</h1>

            <div class="drop-zone" id="dropZone">
                <div class="drop-zone-content">
                    <div class="drop-zone-icon">+</div>
                    <div class="drop-zone-text">„Éï„Ç°„Ç§„É´„Çí„Éâ„É≠„ÉÉ„Éó„Åæ„Åü„ÅØ„ÇØ„É™„ÉÉ„ÇØ</div>
                    <div class="drop-zone-hint">.nbt .schem .we .obj .stl</div>
                </div>
                <input type="file" id="fileInput" accept=".nbt,.schem,.we,.obj,.stl,.mtl,*/*" multiple>
            </div>

            <div class="status-bar" id="statusBar" style="display:none;">
                <span id="fileName"></span>
                <span id="blockCount"></span>
            </div>

            <div class="settings-section">
                <div class="settings-grid">
                    <div class="setting-group">
                        <label>ÊúÄÂ§ßË°åÊï∞</label>
                        <input type="number" id="maxLines" value="30000" min="1000" max="100000">
                    </div>
                    <div class="setting-group">
                        <label>„Çπ„Ç±„Éº„É´</label>
                        <input type="number" id="scale" value="1" min="1" max="10">
                    </div>
                </div>

                <div class="settings-3d" id="settings3D">
                    <div class="settings-group-title">3D„É¢„Éá„É´</div>
                    <div class="settings-grid">
                        <div class="setting-group">
                            <label>Ëß£ÂÉèÂ∫¶</label>
                            <input type="number" id="resolution" value="0.5" min="0.01" max="10" step="0.01">
                        </div>
                        <div class="setting-group">
                            <label>ÂΩ©Ëâ≤ÊñπÊ≥ï</label>
                            <select id="colorMode">
                                <option value="single">Âçò‰∏Ä„Éñ„É≠„ÉÉ„ÇØ</option>
                                <option value="wool">„Ç¶„Éº„É´„ÅÆ„Åø</option>
                                <option value="concrete">„Ç≥„É≥„ÇØ„É™„Éº„Éà„ÅÆ„Åø</option>
                                <option value="terracotta">„ÉÜ„É©„Ç≥„ÉÉ„Çø„ÅÆ„Åø</option>
                                <option value="glass">„Ç¨„É©„Çπ„ÅÆ„Åø</option>
                                <option value="all" selected>„Åô„Åπ„Å¶„ÅÆ„Ç´„É©„Éº„Éñ„É≠„ÉÉ„ÇØ</option>
                            </select>
                        </div>
                    </div>
                    <div class="setting-group" id="blockIdGroup" style="display: none;">
                        <label>„Éñ„É≠„ÉÉ„ÇØ</label>
                        <input type="text" id="blockId" value="default:stone">
                    </div>
                </div>

                <div class="settings-nbt" id="settingsNBT">
                    <div class="settings-custom-convert" id="settingsCustomConvert">
                        <div class="custom-convert-checkbox-wrapper">
                            <input type="checkbox" id="customConvertEnabled">
                            <label for="customConvertEnabled">„Ç´„Çπ„Çø„É†Â§âÊèõ„ÇíÊúâÂäπ„Å´„Åô„Çã</label>
                        </div>
                        <div class="custom-convert-hint" id="customConvertHint" style="display:none;">
                            ‰ªªÊÑè„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„ÇíÂà•„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„Å´ÁΩÆÊèõ„Åß„Åç„Åæ„ÅôÔºàÁ©∫Ê¨Ñ=Â§âÊèõ„Å™„Åó / air=„Çπ„Ç≠„ÉÉ„ÉóÔºâ
                        </div>
                        <div class="custom-convert-list" id="customConvertList" style="display:none;"></div>
                        <button class="custom-convert-add-btn" id="customConvertAddBtn" style="display:none;">
                            + Â§âÊèõ„É´„Éº„É´„ÇíËøΩÂä†
                        </button>
                    </div>

                    <div id="unknownBlocksSection">
                        <div class="settings-group-title">
                            Êú™ÂØæÂøú„Éñ„É≠„ÉÉ„ÇØ
                            <div class="unknown-actions">
                                <button class="unknown-action-btn" id="exportUnknownBtn" title="„Ç®„ÇØ„Çπ„Éù„Éº„Éà">üìã</button>
                                <button class="unknown-action-btn" id="importUnknownBtn" title="„Ç§„É≥„Éù„Éº„Éà">üì•</button>
                            </div>
                        </div>
                        <div class="unknown-hint">Á©∫Ê¨Ñ=„Éá„Éï„Ç©„É´„Éà / air=„Çπ„Ç≠„ÉÉ„Éó</div>
                        <div class="unknown-list" id="unknownList"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="panel right-panel">
            <div class="output-tabs">
                <span class="tab active">„É≠„Ç∞</span>
            </div>
            <div class="log-panel" id="logPanel"></div>
            <div class="download-area" id="downloadArea"></div>

            <div class="progress-section" id="progressSection" style="display:none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-label" id="commandCount"></div>
            </div>

            <div class="action-section">
                <button class="btn-primary" id="convertBtn" disabled>Â§âÊèõ</button>
                <button class="btn-secondary" id="previewBtn" disabled>„Éó„É¨„Éì„É•„Éº</button>
            </div>
        </div>
    </div><!-- Preview Modal -->
    <div class="preview-modal" id="previewModal">
        <div class="preview-header">
            <span class="preview-title">„Éú„ÇØ„Çª„É´„Éó„É¨„Éì„É•„Éº</span>
            <span class="preview-info" id="previewInfo"></span>
            <button class="preview-close" id="previewClose">&times;</button>
        </div>
        <div class="preview-canvas-container">
            <canvas id="previewCanvas"></canvas>
            <div class="preview-hint">„Éâ„É©„ÉÉ„Ç∞„ÅßÂõûËª¢ / „Çπ„ÇØ„É≠„Éº„É´„Åß„Ç∫„Éº„É†</div>
            <div class="preview-controls">
                <button id="resetViewBtn">„É™„Çª„ÉÉ„Éà</button>
                <button id="toggleWireBtn">„ÉØ„Ç§„É§„ÉºË°®Á§∫</button>
            </div>
        </div>
    </div>

    <!-- Import Unknown Blocks Modal -->
    <div class="import-modal" id="importModal">
        <div class="import-modal-content">
            <div class="import-modal-header">
                <span class="import-modal-title">Êú™ÂØæÂøú„Éñ„É≠„ÉÉ„ÇØ„ÅÆ„Ç§„É≥„Éù„Éº„Éà</span>
                <button class="import-modal-close" id="importModalClose">&times;</button>
            </div>
            <div class="import-modal-body">
                <div class="import-modal-hint">
                    ÂΩ¢Âºè: <code>ÂÖÉ„Éñ„É≠„ÉÉ„ÇØ -&gt; Â§âÊèõÂÖà</code> (1Ë°å„Å´1„Å§)<br>
                    ‰æã: <code>minecraft:deepslate -> default:stone</code>
                </div>
                <textarea id="importTextarea" placeholder="„Åì„Åì„Å´„ÉÜ„Ç≠„Çπ„Éà„ÇíË≤º„Çä‰ªò„Åë..."></textarea>
            </div>
            <div class="import-modal-footer">
                <button class="btn-secondary" id="importCancelBtn">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="btn-primary" id="importApplyBtn">ÈÅ©Áî®</button>
            </div>
        </div>
    </div>

    <script>
        // ========== Block Mapping ==========
        const BLOCK_MAPPING = {
            // === Âü∫Êú¨„Éñ„É≠„ÉÉ„ÇØ ===
            "minecraft:air": null, // Skip air blocks
            "minecraft:stone": "default:stone",
            "minecraft:granite": "default:stone",
            "minecraft:polished_granite": "default:stone",
            "minecraft:diorite": "default:stone",
            "minecraft:polished_diorite": "default:stone",
            "minecraft:andesite": "default:stone",
            "minecraft:polished_andesite": "default:stone",
            "minecraft:grass_block": "default:dirt_with_grass",
            "minecraft:grass": "default:dirt_with_grass",
            "minecraft:dirt": "default:dirt",
            "minecraft:coarse_dirt": "default:dirt",
            "minecraft:podzol": "default:dirt",
            "minecraft:cobblestone": "default:cobble",

            // === Êú®Êùê ===
            "minecraft:planks": "default:wood",
            "minecraft:oak_planks": "default:wood",
            "minecraft:spruce_planks": "default:pine_wood",
            "minecraft:birch_planks": "default:birch_wood",
            "minecraft:jungle_planks": "default:junglewood",
            "minecraft:acacia_planks": "default:acacia_wood",
            "minecraft:dark_oak_planks": "default:wood",

            // === ÂéüÊú® ===
            "minecraft:log": "default:tree",
            "minecraft:oak_log": "default:tree",
            "minecraft:spruce_log": "default:pine_tree",
            "minecraft:birch_log": "default:birch_tree",
            "minecraft:jungle_log": "default:jungletree",
            "minecraft:acacia_log": "default:acacia_tree",
            "minecraft:dark_oak_log": "default:tree",

            // === Ëëâ ===
            "minecraft:leaves": "default:leaves",
            "minecraft:oak_leaves": "default:leaves",
            "minecraft:spruce_leaves": "default:pine_needles",
            "minecraft:birch_leaves": "default:birch_leaves",
            "minecraft:jungle_leaves": "default:jungleleaves",
            "minecraft:acacia_leaves": "default:acacia_leaves",
            "minecraft:dark_oak_leaves": "default:leaves",
            "minecraft:leaves2": "default:acacia_leaves",

            // === Á†Ç„ÉªÁ†ÇÂà© ===
            "minecraft:sand": "default:sand",
            "minecraft:red_sand": "default:redsand",
            "minecraft:gravel": "default:gravel",
            "minecraft:sandstone": "default:sandstone",
            "minecraft:chiseled_sandstone": "default:sandstonecarved",
            "minecraft:smooth_sandstone": "default:sandstonesmooth",
            "minecraft:red_sandstone": "default:redsandstone",

            // === Èâ±Áü≥ ===
            "minecraft:gold_ore": "default:stone_with_gold",
            "minecraft:iron_ore": "default:stone_with_iron",
            "minecraft:coal_ore": "default:stone_with_coal",
            "minecraft:diamond_ore": "default:stone_with_diamond",
            "minecraft:emerald_ore": "default:stone_with_emerald",
            "minecraft:lapis_ore": "default:stone_with_bluestone",
            "minecraft:redstone_ore": "default:stone_with_bluestone",
            "minecraft:copper_ore": "default:stone_with_copper",
            "minecraft:quartz_ore": "default:quartz_ore",

            // === Èâ±Áü≥„Éñ„É≠„ÉÉ„ÇØ ===
            "minecraft:gold_block": "default:goldblock",
            "minecraft:iron_block": "default:steelblock",
            "minecraft:diamond_block": "default:diamondblock",
            "minecraft:emerald_block": "default:emeraldblock",
            "minecraft:lapis_block": "default:stone",
            "minecraft:coal_block": "default:coalblock",
            "minecraft:copper_block": "default:copperblock",
            "minecraft:quartz_block": "default:quartz_block",
            "minecraft:chiseled_quartz_block": "default:quartz_chiseled",
            "minecraft:quartz_pillar": "default:quartz_pillar",

            // === „É¨„É≥„Ç¨„ÉªÁü≥Êùê ===
            "minecraft:brick_block": "default:brick",
            "minecraft:bricks": "default:brick",
            "minecraft:stonebrick": "default:stonebrick",
            "minecraft:stone_bricks": "default:stonebrick",
            "minecraft:mossy_stone_bricks": "default:stonebrickmossy",
            "minecraft:cracked_stone_bricks": "default:stonebrickcracked",
            "minecraft:chiseled_stone_bricks": "default:stonebrickcarved",
            "minecraft:mossy_cobblestone": "default:mossycobble",
            "minecraft:nether_brick": "default:brick",

            // === „Ç¨„É©„Çπ ===
            "minecraft:glass": "default:glass",
            "minecraft:glass_pane": "default:glass",
            "minecraft:stained_glass": "default:glass",
            "minecraft:white_stained_glass": "default:glass_white",
            "minecraft:orange_stained_glass": "default:glass_orange",
            "minecraft:magenta_stained_glass": "default:glass_magenta",
            "minecraft:light_blue_stained_glass": "default:glass_cyan",
            "minecraft:yellow_stained_glass": "default:glass_yellow",
            "minecraft:lime_stained_glass": "default:glass_green",
            "minecraft:pink_stained_glass": "default:glass_pink",
            "minecraft:gray_stained_glass": "default:glass_grey",
            "minecraft:light_gray_stained_glass": "default:glass_grey",
            "minecraft:cyan_stained_glass": "default:glass_cyan",
            "minecraft:purple_stained_glass": "default:glass_violet",
            "minecraft:blue_stained_glass": "default:glass_blue",
            "minecraft:brown_stained_glass": "default:glass_brown",
            "minecraft:green_stained_glass": "default:glass_dark_green",
            "minecraft:red_stained_glass": "default:glass_red",
            "minecraft:black_stained_glass": "default:glass_black",

            // === ÁæäÊØõ ===
            "minecraft:wool": "wool:white",
            "minecraft:white_wool": "wool:white",
            "minecraft:orange_wool": "wool:orange",
            "minecraft:magenta_wool": "wool:magenta",
            "minecraft:light_blue_wool": "wool:cyan",
            "minecraft:yellow_wool": "wool:yellow",
            "minecraft:lime_wool": "wool:green",
            "minecraft:pink_wool": "wool:pink",
            "minecraft:gray_wool": "wool:grey",
            "minecraft:light_gray_wool": "wool:grey",
            "minecraft:cyan_wool": "wool:cyan",
            "minecraft:purple_wool": "wool:violet",
            "minecraft:blue_wool": "wool:blue",
            "minecraft:brown_wool": "wool:brown",
            "minecraft:green_wool": "wool:dark_green",
            "minecraft:red_wool": "wool:red",
            "minecraft:black_wool": "wool:black",

            // === „ÉÜ„É©„Ç≥„ÉÉ„Çø ===
            "minecraft:hardened_clay": "default:hardened_clay",
            "minecraft:terracotta": "default:hardened_clay",
            "minecraft:white_terracotta": "hardened_clay:white",
            "minecraft:orange_terracotta": "hardened_clay:orange",
            "minecraft:magenta_terracotta": "hardened_clay:magenta",
            "minecraft:light_blue_terracotta": "hardened_clay:cyan",
            "minecraft:yellow_terracotta": "hardened_clay:yellow",
            "minecraft:lime_terracotta": "hardened_clay:green",
            "minecraft:pink_terracotta": "hardened_clay:pink",
            "minecraft:gray_terracotta": "hardened_clay:grey",
            "minecraft:light_gray_terracotta": "hardened_clay:grey",
            "minecraft:cyan_terracotta": "hardened_clay:cyan",
            "minecraft:purple_terracotta": "hardened_clay:violet",
            "minecraft:blue_terracotta": "hardened_clay:blue",
            "minecraft:brown_terracotta": "hardened_clay:brown",
            "minecraft:green_terracotta": "hardened_clay:dark_green",
            "minecraft:red_terracotta": "hardened_clay:red",
            "minecraft:black_terracotta": "hardened_clay:black",
            "minecraft:stained_hardened_clay": "default:hardened_clay",

            // === „Ç≥„É≥„ÇØ„É™„Éº„Éà ===
            "minecraft:concrete": "concrete:concrete",
            "minecraft:white_concrete": "concrete:concrete_white",
            "minecraft:orange_concrete": "concrete:concrete_orange",
            "minecraft:magenta_concrete": "concrete:concrete_magenta",
            "minecraft:light_blue_concrete": "concrete:concrete_cyan",
            "minecraft:yellow_concrete": "concrete:concrete_yellow",
            "minecraft:lime_concrete": "concrete:concrete_green",
            "minecraft:pink_concrete": "concrete:concrete_pink",
            "minecraft:gray_concrete": "concrete:concrete_grey",
            "minecraft:light_gray_concrete": "concrete:concrete_grey",
            "minecraft:cyan_concrete": "concrete:concrete_cyan",
            "minecraft:purple_concrete": "concrete:concrete_violet",
            "minecraft:blue_concrete": "concrete:concrete_blue",
            "minecraft:brown_concrete": "concrete:concrete_brown",
            "minecraft:green_concrete": "concrete:concrete_dark_green",
            "minecraft:red_concrete": "concrete:concrete_red",
            "minecraft:black_concrete": "concrete:concrete_black",

            // === „Åù„ÅÆ‰ªñ„Éñ„É≠„ÉÉ„ÇØ ===
            "minecraft:bedrock": "default:stone",
            "minecraft:sponge": "sponge:sponge",
            "minecraft:obsidian": "default:obsidian",
            "minecraft:glowstone": "default:glowstone",
            "minecraft:ice": "default:ice",
            "minecraft:packed_ice": "default:packedice",
            "minecraft:snow": "default:snowblock",
            "minecraft:snow_block": "default:snowblock",
            "minecraft:snow_layer": "default:snowblock",
            "minecraft:clay": "default:clay",
            "minecraft:cactus": "default:cactus",
            "minecraft:bookshelf": "shelf:bookshelf",
            "minecraft:slime": "bluestone_stickyblocks:slimeblock",
            "minecraft:slime_block": "bluestone_stickyblocks:slimeblock",
            "minecraft:melon": "farming_plants:watermelon_fruit",
            "minecraft:melon_block": "farming_plants:watermelon_fruit",
            "minecraft:pumpkin": "farming_plants:pumpkin_fruit",
            "minecraft:hay_block": "farming:straw",

            // === Ê©üËÉΩ„Éñ„É≠„ÉÉ„ÇØ ===
            "minecraft:chest": "default:chest",
            "minecraft:crafting_table": "workbench:workbench",
            "minecraft:furnace": "default:furnace",
            "minecraft:lit_furnace": "default:furnace",

            // === ÈöéÊÆµ (Âü∫Êú¨„Éû„ÉÉ„Éî„É≥„Ç∞) ===
            "minecraft:oak_stairs": "stairs:stair_default_wood",
            "minecraft:spruce_stairs": "stairs:stair_default_pine_wood",
            "minecraft:birch_stairs": "stairs:stair_default_birch_wood",
            "minecraft:jungle_stairs": "stairs:stair_default_junglewood",
            "minecraft:acacia_stairs": "stairs:stair_default_acacia_wood",
            "minecraft:dark_oak_stairs": "stairs:stair_default_wood",
            "minecraft:stone_stairs": "stairs:stair_default_cobble",
            "minecraft:cobblestone_stairs": "stairs:stair_default_cobble",
            "minecraft:brick_stairs": "stairs:stair_default_brick",
            "minecraft:stone_brick_stairs": "stairs:stair_default_stonebrick",
            "minecraft:sandstone_stairs": "stairs:stair_default_sandstone",
            "minecraft:quartz_stairs": "stairs:stair_default_quartz_block",

            // === „Éè„Éº„Éï„Éñ„É≠„ÉÉ„ÇØ (Âü∫Êú¨„Éû„ÉÉ„Éî„É≥„Ç∞) ===
            "minecraft:stone_slab": "stairs:slab_default_stone",
            "minecraft:oak_slab": "stairs:slab_default_wood",
            "minecraft:spruce_slab": "stairs:slab_default_pine_wood",
            "minecraft:birch_slab": "stairs:slab_default_birch_wood",
            "minecraft:jungle_slab": "stairs:slab_default_junglewood",
            "minecraft:acacia_slab": "stairs:slab_default_acacia_wood",
            "minecraft:dark_oak_slab": "stairs:slab_default_wood",
            "minecraft:brick_slab": "stairs:slab_default_brick",
            "minecraft:stone_brick_slab": "stairs:slab_default_stonebrick",
            "minecraft:sandstone_slab": "stairs:slab_default_sandstone",
            "minecraft:quartz_slab": "stairs:slab_default_quartz_block",

            // === ÊùæÊòé„ÉªÁÖßÊòé ===
            "minecraft:torch": "default:torch",
            "minecraft:wall_torch": "default:torch",
            "minecraft:lantern": "lanterns:lantern_off",
            "minecraft:soul_lantern": "lanterns:lantern_off",
            "minecraft:redstone_lamp": "default:glowstone",
            "minecraft:lit_redstone_lamp": "default:glowstone",

            // === „ÅØ„Åó„Åî ===
            "minecraft:ladder": "default:ladder_wood",

            // === „Éï„Çß„É≥„Çπ ===
            "minecraft:fence": "default:fence_wood",
            "minecraft:oak_fence": "default:fence_wood",
            "minecraft:spruce_fence": "default:fence_pine_wood",
            "minecraft:birch_fence": "default:fence_birch_wood",
            "minecraft:jungle_fence": "default:fence_jungle_wood",
            "minecraft:acacia_fence": "default:fence_acacia_wood",
            "minecraft:dark_oak_fence": "default:fence_wood",
            "minecraft:nether_brick_fence": "default:fence_wood",

            // === „Éï„Çß„É≥„Çπ„Ç≤„Éº„Éà ===
            "minecraft:fence_gate": "doors:gate_wood",
            "minecraft:oak_fence_gate": "doors:gate_wood",
            "minecraft:spruce_fence_gate": "doors:gate_pine_wood",
            "minecraft:birch_fence_gate": "doors:gate_birch_wood",
            "minecraft:jungle_fence_gate": "doors:gate_jungle_wood",
            "minecraft:acacia_fence_gate": "doors:gate_acacia_wood",
            "minecraft:dark_oak_fence_gate": "doors:gate_wood",

            // === „Éâ„Ç¢ ===
            "minecraft:wooden_door": "doors:door_wood",
            "minecraft:oak_door": "doors:door_wood",
            "minecraft:spruce_door": "doors:door_pine_wood",
            "minecraft:birch_door": "doors:door_birch_wood",
            "minecraft:jungle_door": "doors:door_jungle_wood",
            "minecraft:acacia_door": "doors:door_acacia_wood",
            "minecraft:dark_oak_door": "doors:door_wood",
            "minecraft:iron_door": "doors:door_steel",

            // === „Éà„É©„ÉÉ„Éó„Éâ„Ç¢ ===
            "minecraft:trapdoor": "doors:trapdoor",
            "minecraft:oak_trapdoor": "doors:trapdoor",
            "minecraft:spruce_trapdoor": "doors:trapdoor_pine_wood",
            "minecraft:birch_trapdoor": "doors:trapdoor_birch_wood",
            "minecraft:jungle_trapdoor": "doors:trapdoor_jungle_wood",
            "minecraft:acacia_trapdoor": "doors:trapdoor_acacia_wood",
            "minecraft:dark_oak_trapdoor": "doors:trapdoor",
            "minecraft:iron_trapdoor": "doors:trapdoor_steel",

            // === „Éô„ÉÉ„Éâ ===
            "minecraft:bed": "beds:bed_red",
            "minecraft:white_bed": "beds:bed_white",
            "minecraft:orange_bed": "beds:bed_orange",
            "minecraft:magenta_bed": "beds:bed_magenta",
            "minecraft:light_blue_bed": "beds:bed_cyan",
            "minecraft:yellow_bed": "beds:bed_yellow",
            "minecraft:lime_bed": "beds:bed_green",
            "minecraft:pink_bed": "beds:bed_pink",
            "minecraft:gray_bed": "beds:bed_grey",
            "minecraft:light_gray_bed": "beds:bed_grey",
            "minecraft:cyan_bed": "beds:bed_cyan",
            "minecraft:purple_bed": "beds:bed_violet",
            "minecraft:blue_bed": "beds:bed_blue",
            "minecraft:brown_bed": "beds:bed_brown",
            "minecraft:green_bed": "beds:bed_dark_green",
            "minecraft:red_bed": "beds:bed_red",
            "minecraft:black_bed": "beds:bed_black",

            // === „É¨„Éº„É´ ===
            "minecraft:rail": "carts:rail",
            "minecraft:golden_rail": "carts:rail",
            "minecraft:powered_rail": "carts:rail",
            "minecraft:detector_rail": "carts:rail",
            "minecraft:activator_rail": "carts:rail",

            // === TNT ===
            "minecraft:tnt": "tnt:tnt",

            // === „Ç¨„É©„ÇπÊùø„ÉªÈâÑÊ†ºÂ≠ê ===
            "minecraft:stained_glass_pane": "xpanes:pane_flat",
            "minecraft:iron_bars": "xpanes:bar_flat",

            // === „ÇØ„É¢„ÅÆÂ∑£ ===
            "minecraft:web": "mobs_monsters:cobweb",
            "minecraft:cobweb": "mobs_monsters:cobweb",

            // === „Çµ„É≥„Ç¥„Éñ„É≠„ÉÉ„ÇØ ===
            "minecraft:tube_coral_block": "ocean:coral_blue_tubular_block",
            "minecraft:brain_coral_block": "ocean:coral_pink_acropora_block",
            "minecraft:bubble_coral_block": "ocean:coral_yellow_fiery_block",
            "minecraft:fire_coral_block": "ocean:coral_red_rubrum_block",
            "minecraft:horn_coral_block": "ocean:coral_yellow_fiery_block",

            // === ÁúãÊùø ===
            "minecraft:standing_sign": "signs:sign",
            "minecraft:wall_sign": "signs:sign",
            "minecraft:oak_sign": "signs:sign",
            "minecraft:spruce_sign": "signs:sign_pine_wood",
            "minecraft:birch_sign": "signs:sign_birch_wood",
            "minecraft:jungle_sign": "signs:sign_junglewood",
            "minecraft:acacia_sign": "signs:sign_acacia_wood",
            "minecraft:dark_oak_sign": "signs:sign",

            // === „Åù„ÅÆ‰ªñ„ÅÆËøΩÂä†„Éñ„É≠„ÉÉ„ÇØ ===
            "minecraft:bamboo": "water_plants:bamboo",
            "minecraft:lily_pad": "swamp_biome:waterlily",
            "minecraft:waterlily": "swamp_biome:waterlily",
            "minecraft:jack_o_lantern": "farming_plants:pumpkin_fruit",
            "minecraft:lit_pumpkin": "farming_plants:pumpkin_fruit",
            "minecraft:carved_pumpkin": "farming_plants:pumpkin_fruit",
            "minecraft:jukebox": "default:chest",
            "minecraft:enchanting_table": "x_enchanting:table",
            "minecraft:brewing_stand": "brewing:stand",
            "minecraft:armor_stand": "3d_armor_stand:armor_stand",
            "minecraft:flower_pot": "flowerpot:pot",
            "minecraft:painting": "painting:painting",
            "minecraft:item_frame": "itemframes:frame",
        };

        // ========== NBT Parser ==========
        class NBTReader {
            constructor(buffer) {
                this.view = new DataView(buffer);
                this.offset = 0;
            }
            readByte() { return this.view.getInt8(this.offset++); }
            readShort() { const v = this.view.getInt16(this.offset, false); this.offset += 2; return v; }
            readInt() { const v = this.view.getInt32(this.offset, false); this.offset += 4; return v; }
            readLong() {
                const h = this.view.getInt32(this.offset, false);
                const l = this.view.getUint32(this.offset + 4, false);
                this.offset += 8;
                return BigInt(h) * BigInt(0x100000000) + BigInt(l);
            }
            readFloat() { const v = this.view.getFloat32(this.offset, false); this.offset += 4; return v; }
            readDouble() { const v = this.view.getFloat64(this.offset, false); this.offset += 8; return v; }
            readString() {
                const len = this.view.getUint16(this.offset, false);
                this.offset += 2;
                const bytes = new Uint8Array(this.view.buffer, this.offset, len);
                this.offset += len;
                return new TextDecoder('utf-8').decode(bytes);
            }
            readByteArray() {
                const len = this.readInt();
                const arr = new Int8Array(this.view.buffer, this.offset, len);
                this.offset += len;
                return Array.from(arr);
            }
            readIntArray() {
                const len = this.readInt();
                const arr = [];
                for (let i = 0; i < len; i++) arr.push(this.readInt());
                return arr;
            }
            readLongArray() {
                const len = this.readInt();
                const arr = [];
                for (let i = 0; i < len; i++) arr.push(this.readLong());
                return arr;
            }
            readList() {
                const type = this.readByte();
                const len = this.readInt();
                const list = [];
                for (let i = 0; i < len; i++) list.push(this.readTag(type));
                return list;
            }
            readCompound() {
                const compound = {};
                while (true) {
                    const type = this.readByte();
                    if (type === 0) break;
                    const name = this.readString();
                    compound[name] = this.readTag(type);
                }
                return compound;
            }
            readTag(type) {
                switch (type) {
                    case 0: return null;
                    case 1: return this.readByte();
                    case 2: return this.readShort();
                    case 3: return this.readInt();
                    case 4: return this.readLong();
                    case 5: return this.readFloat();
                    case 6: return this.readDouble();
                    case 7: return this.readByteArray();
                    case 8: return this.readString();
                    case 9: return this.readList();
                    case 10: return this.readCompound();
                    case 11: return this.readIntArray();
                    case 12: return this.readLongArray();
                    default: throw new Error(`Unknown tag: ${type}`);
                }
            }
            parse() {
                const type = this.readByte();
                if (type !== 10) throw new Error('Invalid root');
                this.readString();
                return this.readCompound();
            }
        }

        // ========== State ==========
        let currentBlocks = [];
        let current3DVoxels = [];
        let unknownBlocks = {};
        let userMappings = {};
        let currentFileName = '';
        let is3DModel = false;
        let isWorldEdit = false;
        let userResolutionLocked = false;
        let currentGeometry = null;
        let customConvertEnabled = false;
        let customConvertEntries = [];

        // ========== DOM ==========
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const unknownList = document.getElementById('unknownList');
        const convertBtn = document.getElementById('convertBtn');
        const downloadArea = document.getElementById('downloadArea');
        const logPanel = document.getElementById('logPanel');
        const resolutionInput = document.getElementById('resolution');
        const settings3D = document.getElementById('settings3D');
        const settingsNBT = document.getElementById('settingsNBT');
        const colorModeSelect = document.getElementById('colorMode');
        const blockIdGroup = document.getElementById('blockIdGroup');
        const customConvertCheckbox = document.getElementById('customConvertEnabled');
        const customConvertList = document.getElementById('customConvertList');
        const customConvertAddBtn = document.getElementById('customConvertAddBtn');
        const customConvertHint = document.getElementById('customConvertHint');
        const unknownBlocksSection = document.getElementById('unknownBlocksSection');

        // Track if the user manually edited the resolution so we don't overwrite it on the next file
        resolutionInput.addEventListener('input', () => { userResolutionLocked = true; });

        // ÂΩ©Ëâ≤ÊñπÊ≥ï„ÅÆÂ§âÊõ¥ÊôÇ„Å´„Éñ„É≠„ÉÉ„ÇØÂÖ•ÂäõÊ¨Ñ„ÅÆË°®Á§∫/ÈùûË°®Á§∫„ÇíÂàá„ÇäÊõø„Åà
        colorModeSelect.addEventListener('change', () => {
            if (colorModeSelect.value === 'single') {
                blockIdGroup.style.display = 'block';
            } else {
                blockIdGroup.style.display = 'none';
            }
        });

        // Toggle settings sections visibility
        function updateSettingsVisibility() {
            if (is3DModel) {
                settings3D.classList.add('visible');
                settingsNBT.classList.remove('visible');
            } else {
                settings3D.classList.remove('visible');
                // 3D„É¢„Éá„É´‰ª•Â§ñ„ÅÆÂ†¥Âêà„ÅØÂ∏∏„Å´settingsNBT„ÇíË°®Á§∫Ôºà„Ç´„Çπ„Çø„É†Â§âÊèõ„ÅÆ„Åü„ÇÅÔºâ
                settingsNBT.classList.add('visible');
                // Êú™ÂØæÂøú„Éñ„É≠„ÉÉ„ÇØ„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„ÅøÊú™ÂØæÂøú„Éñ„É≠„ÉÉ„ÇØ„Çª„ÇØ„Ç∑„Éß„É≥„ÇíË°®Á§∫
                if (Object.keys(unknownBlocks).length > 0) {
                    unknownBlocksSection.style.display = 'block';
                } else {
                    unknownBlocksSection.style.display = 'none';
                }
            }
        }

        // backward compat
        function update3DSettingsVisibility() {
            updateSettingsVisibility();
        }


        // ========== Utils ==========
        function log(msg, type = '') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = msg;
            logPanel.appendChild(entry);
            logPanel.scrollTop = logPanel.scrollHeight;
        }

        function updateStatus(key, value) {
            const el = document.getElementById(key);
            if (el) el.textContent = value;
        }

        function setProgress(pct) {
            document.getElementById('progressFill').style.width = `${pct}%`;
        }

        function parseBlockState(name) {
            if (!name.includes('[')) return [name, {}];
            const base = name.split('[')[0];
            const statesStr = name.split('[')[1].replace(']', '');
            const states = {};
            for (const pair of statesStr.split(',')) {
                if (pair.includes('=')) {
                    const [k, v] = pair.split('=');
                    states[k.trim()] = v.trim();
                }
            }
            return [base, states];
        }

        function isStair(name) { return name.toLowerCase().includes('stairs'); }
        function isSlab(name) { return name.toLowerCase().includes('slab'); }
        function isTrapdoor(name) { return name.toLowerCase().includes('trapdoor'); }
        function isDoor(name) { return name.toLowerCase().includes('_door') && !name.toLowerCase().includes('trapdoor'); }
        function isLadder(name) { return name.toLowerCase().includes('ladder'); }
        function isFenceGate(name) { return name.toLowerCase().includes('fence_gate'); }
        function isButton(name) { return name.toLowerCase().includes('button'); }
        function isLever(name) { return name.toLowerCase().includes('lever'); }
        function isSign(name) { return name.toLowerCase().includes('sign'); }
        function isChest(name) { return name.toLowerCase().includes('chest'); }
        function isFurnace(name) { return name.toLowerCase().includes('furnace'); }

        function getParam2Stairs(states) {
            const map = { north: 2, south: 0, east: 1, west: 3 };
            let p = map[states.facing] || 0;
            if (states.half === 'top') p += 20;
            return p;
        }

        function getParam2Slab(states) {
            if (states.type === 'top') return 20;
            if (states.type === 'double') return -1;
            return 0;
        }

        // „Éà„É©„ÉÉ„Éó„Éâ„Ç¢: facing + half + open
        function getParam2Trapdoor(states) {
            // Minetest„ÅÆ„Éà„É©„ÉÉ„Éó„Éâ„Ç¢ param2:
            // 0-3: ‰∏ãÂÅ¥„ÄÅÈñâ„Åò (facingÊñπÂêë)
            // 4-7: ‰∏ãÂÅ¥„ÄÅÈñã„Åç
            // 20-23: ‰∏äÂÅ¥„ÄÅÈñâ„Åò
            // 24-27: ‰∏äÂÅ¥„ÄÅÈñã„Åç (ÈùûÊ®ôÊ∫ñ„Å†„Åå‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅ)
            const facingMap = { north: 2, south: 0, east: 1, west: 3 };
            let p = facingMap[states.facing] || 0;
            if (states.open === 'true') p += 4;
            if (states.half === 'top') p += 20;
            return p;
        }

        // „Éâ„Ç¢: facing + hinge + half
        function getParam2Door(states) {
            // Minetest„ÅÆ„Éâ„Ç¢ param2: 0-3 (facingÊñπÂêë)
            const facingMap = { north: 2, south: 0, east: 3, west: 1 };
            let p = facingMap[states.facing] || 0;
            // hinge„Ååright„ÅÆÂ†¥Âêà„ÄÅÂèçËª¢
            if (states.hinge === 'right') p = (p + 2) % 4;
            return p;
        }

        // „ÅØ„Åó„Åî: facing
        function getParam2Ladder(states) {
            const facingMap = { north: 5, south: 4, east: 2, west: 3 };
            return facingMap[states.facing] || 2;
        }

        // „Éï„Çß„É≥„Çπ„Ç≤„Éº„Éà: facing
        function getParam2FenceGate(states) {
            const facingMap = { north: 2, south: 0, east: 1, west: 3 };
            let p = facingMap[states.facing] || 0;
            if (states.open === 'true') p += 4;
            return p;
        }

        // „Éú„Çø„É≥: facing + face
        function getParam2Button(states) {
            if (states.face === 'ceiling') return 0;
            if (states.face === 'floor') return 5;
            const facingMap = { north: 4, south: 3, east: 2, west: 1 };
            return facingMap[states.facing] || 3;
        }

        // „É¨„Éê„Éº: facing + face
        function getParam2Lever(states) {
            if (states.face === 'ceiling') return 0;
            if (states.face === 'floor') return 5;
            const facingMap = { north: 4, south: 3, east: 2, west: 1 };
            return facingMap[states.facing] || 3;
        }

        // Ë®≠ÁΩÆÂûã„Éñ„É≠„ÉÉ„ÇØÔºà„ÉÅ„Çß„Çπ„Éà„ÄÅ„Åã„Åæ„Å©Á≠âÔºâ: facing
        function getParam2Facing(states) {
            const facingMap = { north: 0, south: 2, east: 3, west: 1 };
            return facingMap[states.facing] || 0;
        }

        function getMulticraftBlock(mcName) {
            let [base, states] = parseBlockState(mcName.toLowerCase());
            if (!base.startsWith('minecraft:')) base = 'minecraft:' + base;

            let param2 = 0;
            if (isStair(base)) param2 = getParam2Stairs(states);
            else if (isSlab(base)) param2 = getParam2Slab(states);
            else if (isTrapdoor(base)) param2 = getParam2Trapdoor(states);
            else if (isDoor(base)) param2 = getParam2Door(states);
            else if (isLadder(base)) param2 = getParam2Ladder(states);
            else if (isFenceGate(base)) param2 = getParam2FenceGate(states);
            else if (isButton(base)) param2 = getParam2Button(states);
            else if (isLever(base)) param2 = getParam2Lever(states);
            else if (isChest(base) || isFurnace(base)) param2 = getParam2Facing(states);

            if (userMappings[base] !== undefined) {
                if (userMappings[base] === null) return [null, 0];
                return [userMappings[base], param2];
            }
            if (BLOCK_MAPPING[base] !== undefined) {
                if (BLOCK_MAPPING[base] === null) return [null, 0];
                return [BLOCK_MAPPING[base], param2];
            }
            return [base.replace('minecraft:', 'default:'), param2];
        }

        // ========== Autocomplete ==========
        function setupAutocomplete(input) {
            const wrapper = input.parentElement;
            const list = wrapper.querySelector('.autocomplete-list');

            input.addEventListener('input', () => {
                const val = input.value.toLowerCase();
                if (val.length < 1) {
                    list.classList.remove('visible');
                    return;
                }

                const matches = allItems.filter(item =>
                    item.id.toLowerCase().includes(val) ||
                    item.name.toLowerCase().includes(val)
                ).slice(0, 10);

                if (matches.length === 0) {
                    list.classList.remove('visible');
                    return;
                }

                list.innerHTML = matches.map(item => `
                <div class="autocomplete-item" data-id="${item.id}">
                    <div class="item-id">${item.id}</div>
                    <div class="item-name">${item.name}</div>
                </div>
            `).join('');

                list.classList.add('visible');
            });

            list.addEventListener('click', (e) => {
                const item = e.target.closest('.autocomplete-item');
                if (item) {
                    input.value = item.dataset.id;
                    list.classList.remove('visible');
                }
            });

            input.addEventListener('blur', () => {
                setTimeout(() => list.classList.remove('visible'), 200);
            });
        }

        // ========== NBT Load ==========
        function loadNBT(data) {
            const nbt = new NBTReader(data.buffer).parse();
            if (!nbt.palette || !nbt.blocks) throw new Error('Invalid NBT');

            const blocks = [];
            for (const b of nbt.blocks) {
                const state = b.state;
                if (state < nbt.palette.length) {
                    const name = nbt.palette[state].Name;
                    if (name && name !== 'minecraft:air' && name !== 'air') {
                        blocks.push([Number(b.pos[0]), Number(b.pos[1]), Number(b.pos[2]), name]);
                    }
                }
            }
            return blocks;
        }

        // ========== Sponge Schematic (.schem) Load ==========
        function loadSchem(data) {
            const nbt = new NBTReader(data.buffer).parse();

            // Determine schematic version and get the correct data source
            // v3: data is nested under "Schematic" tag with Blocks.Data and Blocks.Palette
            // v2: data is at root level with BlockData and Palette
            let schematic = nbt;
            let version = 2;

            // Check for v3 format (nested under Schematic tag)
            if (nbt.Schematic) {
                schematic = nbt.Schematic;
                version = schematic.Version || 3;
                log(`Sponge Schematic v${version} „Éï„Ç©„Éº„Éû„ÉÉ„Éà„ÇíÊ§úÂá∫`, 'info');
            } else if (nbt.Version) {
                version = nbt.Version;
                log(`Sponge Schematic v${version} „Éï„Ç©„Éº„Éû„ÉÉ„Éà„ÇíÊ§úÂá∫`, 'info');
            }

            // Sponge Schematic fields
            const width = schematic.Width;
            const height = schematic.Height;
            const length = schematic.Length;

            // v3 uses Blocks.Palette and Blocks.Data, v2 uses Palette and BlockData
            let palette, blockData;
            if (version >= 3 && schematic.Blocks) {
                palette = schematic.Blocks.Palette;
                blockData = schematic.Blocks.Data;
                log('v3ÂΩ¢Âºè: Blocks.Palette „Å® Blocks.Data „Çí‰ΩøÁî®', 'info');
            } else {
                palette = schematic.Palette;
                blockData = schematic.BlockData;
            }

            if (width === undefined || height === undefined || length === undefined) {
                // Debug: show what fields are available
                const availableFields = Object.keys(schematic).join(', ');
                log(`Âà©Áî®ÂèØËÉΩ„Å™„Éï„Ç£„Éº„É´„Éâ: ${availableFields}`, 'warning');
                throw new Error('Invalid .schem file format: Missing dimension fields (Width/Height/Length)');
            }

            if (!palette) {
                throw new Error('Invalid .schem file format: Missing Palette');
            }

            if (!blockData) {
                throw new Error('Invalid .schem file format: Missing BlockData');
            }

            log(`„Çµ„Ç§„Ç∫: ${width}x${height}x${length}`, 'info');

            // Invert palette: ID -> Name
            const idToName = {};
            let maxId = 0;
            for (const [name, id] of Object.entries(palette)) {
                idToName[id] = name;
                if (id > maxId) maxId = id;
            }

            const blocks = [];
            let offset = 0;
            const totalBlocks = width * height * length;

            for (let i = 0; i < totalBlocks; i++) {
                // Read VarInt from blockData
                let value = 0;
                let shift = 0;
                while (true) {
                    if (offset >= blockData.length) break;
                    const byte = blockData[offset++];
                    value |= (byte & 0x7F) << shift;
                    shift += 7;
                    if ((byte & 0x80) === 0) break;
                }

                const blockId = value;
                const name = idToName[blockId];

                if (name && name !== 'minecraft:air' && name !== 'air' && !name.endsWith(':air')) {
                    // v2: Index = (y * Length + z) * Width + x (YZX order)
                    // v3: Index = x + z * Width + y * Width * Length (XZY order)
                    let x, y, z;
                    if (version >= 3) {
                        // v3 XZY order
                        x = i % width;
                        z = Math.floor(i / width) % length;
                        y = Math.floor(i / (width * length));
                    } else {
                        // v2 YZX order
                        y = Math.floor(i / (width * length));
                        const rem = i % (width * length);
                        z = Math.floor(rem / width);
                        x = rem % width;
                    }

                    blocks.push([x, y, z, name]);
                }
            }

            log(`${blocks.length}ÂÄã„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü`, 'success');
            return blocks;
        }

        // ========== WorldEdit (.we) Load ==========
        function loadWorldEdit(text) {
            // WorldEdit format: "5:return {{["z"] = 0, ["y"] = 0, ["name"] = "block:id", ["x"] = 0}, ...}"
            const blocks = [];

            // „Éê„Éº„Ç∏„Éß„É≥Áï™Âè∑„Å®"return"„ÇíÈô§Âéª„Åó„Å¶„ÉÜ„Éº„Éñ„É´ÈÉ®ÂàÜ„ÇíÂèñÂæó
            const match = text.match(/^\d+:return\s*\{(.*)\}\s*$/s);
            if (!match) {
                throw new Error('Invalid WorldEdit format');
            }

            const tableContent = match[1];

            // ÂêÑ„Éñ„É≠„ÉÉ„ÇØ„Ç®„É≥„Éà„É™„ÇíÊäΩÂá∫
            // „Éë„Çø„Éº„É≥: {["z"] = 0, ["param2"] = 8, ["y"] = 0, ["param1"] = 15, ["name"] = "...", ["x"] = 0}
            let depth = 0;
            let start = -1;
            const entries = [];

            for (let i = 0; i < tableContent.length; i++) {
                const ch = tableContent[i];
                if (ch === '{') {
                    if (depth === 0) start = i;
                    depth++;
                } else if (ch === '}') {
                    depth--;
                    if (depth === 0 && start !== -1) {
                        entries.push(tableContent.substring(start + 1, i));
                        start = -1;
                    }
                }
            }

            for (const entry of entries) {
                // ÂêÑ„Éï„Ç£„Éº„É´„Éâ„ÇíÊäΩÂá∫
                const xMatch = entry.match(/\["x"\]\s*=\s*(-?\d+)/);
                const yMatch = entry.match(/\["y"\]\s*=\s*(-?\d+)/);
                const zMatch = entry.match(/\["z"\]\s*=\s*(-?\d+)/);
                const nameMatch = entry.match(/\["name"\]\s*=\s*"([^"]+)"/);

                if (xMatch && yMatch && zMatch && nameMatch) {
                    const x = parseInt(xMatch[1]);
                    const y = parseInt(yMatch[1]);
                    const z = parseInt(zMatch[1]);
                    const name = nameMatch[1];

                    // param2ÔºàÂõûËª¢ÊÉÖÂ†±Ôºâ„Åå„ÅÇ„Çå„Å∞ÂèñÂæó
                    const param2Match = entry.match(/\["param2"\]\s*=\s*(\d+)/);
                    const param2 = param2Match ? parseInt(param2Match[1]) : 0;

                    // air„Éñ„É≠„ÉÉ„ÇØ„ÅØ„Çπ„Ç≠„ÉÉ„Éó
                    if (name !== 'air' && !name.endsWith(':air')) {
                        blocks.push([x, y, z, name, param2]);
                    }
                }
            }

            if (blocks.length === 0) {
                throw new Error('No blocks found in WorldEdit file');
            }

            return blocks;
        }

        // ========== 3D Model Loader ==========
        let pendingMtlContent = null; // MTL„Éï„Ç°„Ç§„É´„ÅÆÂÜÖÂÆπ„Çí‰∏ÄÊôÇ‰øùÂ≠ò

        function load3DModel(file, mtlContent = null) {
            return new Promise((resolve, reject) => {
                const ext = file.name.split('.').pop().toLowerCase();
                const reader = new FileReader();

                reader.onload = (e) => {
                    try {
                        let geometry = null;

                        if (ext === 'obj') {
                            const objLoader = new THREE.OBJLoader();

                            // MTL„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Éû„ÉÜ„É™„Ç¢„É´„ÇíÈÅ©Áî®
                            if (mtlContent || pendingMtlContent) {
                                const mtlText = mtlContent || pendingMtlContent;

                                // MTL„Éï„Ç°„Ç§„É´„ÅÆÂÜÖÂÆπ„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                                const hasDirectColor = /^\s*Kd\s+[\d.]+\s+[\d.]+\s+[\d.]+/m.test(mtlText);
                                const hasTexture = /^\s*map_Kd\s+/m.test(mtlText);

                                if (hasTexture && !hasDirectColor) {
                                    log('Ë≠¶Âëä: MTL„Éï„Ç°„Ç§„É´„ÅØ„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíÂèÇÁÖß„Åó„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ„ÉÜ„ÇØ„Çπ„ÉÅ„É£„Éï„Ç°„Ç§„É´„ÅØË™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì', 'warning');
                                    log('Ëâ≤ÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã„Å´„ÅØMTL„Éï„Ç°„Ç§„É´„Å´KdÔºà„Éá„Ç£„Éï„É•„Éº„Ç∫„Ç´„É©„ÉºÔºâ„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ', 'warning');
                                }

                                const mtlLoader = new THREE.MTLLoader();
                                const materials = mtlLoader.parse(mtlText);
                                materials.preload();
                                objLoader.setMaterials(materials);

                                if (hasDirectColor) {
                                    log('MTL„Éû„ÉÜ„É™„Ç¢„É´„ÇíÈÅ©Áî®„Åó„Åæ„Åó„Åü', 'success');
                                }
                                pendingMtlContent = null; // ‰ΩøÁî®Âæå„ÇØ„É™„Ç¢
                            }

                            const obj = objLoader.parse(e.target.result);
                            geometry = mergeGeometries(obj);
                        } else if (ext === 'stl') {
                            const loader = new THREE.STLLoader();
                            geometry = loader.parse(e.target.result);

                        } else {
                            reject(new Error(`Êú™ÂØæÂøú„ÅÆ„Éï„Ç°„Ç§„É´ÂΩ¢Âºè: ${ext}`));
                            return;
                        }

                        if (!geometry) {
                            reject(new Error('„Ç∏„Ç™„É°„Éà„É™„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'));
                            return;
                        }

                        resolve(geometry);
                    } catch (err) {
                        reject(err);
                    }
                };

                reader.onerror = () => {
                    reject(new Error('„Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'));
                };

                if (ext === 'obj') {
                    reader.readAsText(file);
                } else {
                    reader.readAsArrayBuffer(file);
                }
            });
        }

        function mergeGeometries(object) {
            const geometries = [];
            let materialCount = 0;
            let meshCount = 0;
            const detectedColors = new Set();

            object.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    meshCount++;
                    const geom = child.geometry.clone();
                    child.updateWorldMatrix(true, false);
                    geom.applyMatrix4(child.matrixWorld);

                    // „Éû„ÉÜ„É™„Ç¢„É´„Åã„ÇâËâ≤„ÇíÂèñÂæó„Åó„Å¶„Ç∏„Ç™„É°„Éà„É™„Å´È†ÇÁÇπ„Ç´„É©„Éº„Å®„Åó„Å¶ËøΩÂä†
                    const pos = geom.getAttribute('position');
                    if (!geom.getAttribute('color') && pos) {
                        const colors = [];

                        // „Éû„ÉÜ„É™„Ç¢„É´„ÅåÈÖçÂàó„ÅÆÂ†¥ÂêàÔºàË§áÊï∞„Éû„ÉÜ„É™„Ç¢„É´Ôºâ
                        if (Array.isArray(child.material)) {
                            // „Ç∞„É´„Éº„ÉóÊÉÖÂ†±„Çí‰Ωø„Å£„Å¶ÂêÑÈ†ÇÁÇπ„Å´Ëâ≤„ÇíÂâ≤„ÇäÂΩì„Å¶
                            const groups = geom.groups;
                            if (groups && groups.length > 0) {
                                // È†ÇÁÇπ„Åî„Å®„ÅÆËâ≤„ÇíÂàùÊúüÂåñ
                                for (let i = 0; i < pos.count; i++) {
                                    colors.push(0.5, 0.5, 0.5);
                                }
                                // „Ç∞„É´„Éº„Éó„Åî„Å®„Å´Ëâ≤„ÇíË®≠ÂÆö
                                for (const group of groups) {
                                    const mat = child.material[group.materialIndex];
                                    if (mat && mat.color) {
                                        const mc = mat.color;
                                        materialCount++;
                                        const r255 = Math.round(mc.r * 255);
                                        const g255 = Math.round(mc.g * 255);
                                        const b255 = Math.round(mc.b * 255);
                                        detectedColors.add(`RGB(${r255},${g255},${b255})`);
                                        for (let i = group.start; i < group.start + group.count; i++) {
                                            colors[i * 3] = mc.r;
                                            colors[i * 3 + 1] = mc.g;
                                            colors[i * 3 + 2] = mc.b;
                                        }
                                    }
                                }
                                geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                            } else {
                                // „Ç∞„É´„Éº„Éó„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÊúÄÂàù„ÅÆ„Éû„ÉÜ„É™„Ç¢„É´„Çí‰ΩøÁî®
                                const mat = child.material[0];
                                if (mat && mat.color) {
                                    const mc = mat.color;
                                    const isDefaultWhite = (mc.r === 1 && mc.g === 1 && mc.b === 1);
                                    if (!isDefaultWhite) {
                                        const r255 = Math.round(mc.r * 255);
                                        const g255 = Math.round(mc.g * 255);
                                        const b255 = Math.round(mc.b * 255);
                                        detectedColors.add(`RGB(${r255},${g255},${b255})`);
                                        for (let i = 0; i < pos.count; i++) {
                                            colors.push(mc.r, mc.g, mc.b);
                                        }
                                        geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                                    }
                                }
                            }
                        } else if (child.material && child.material.color) {
                            // Âçò‰∏Ä„Éû„ÉÜ„É™„Ç¢„É´
                            const mc = child.material.color;
                            const isDefaultWhite = (mc.r === 1 && mc.g === 1 && mc.b === 1);
                            if (!isDefaultWhite) {
                                materialCount++;
                                const r255 = Math.round(mc.r * 255);
                                const g255 = Math.round(mc.g * 255);
                                const b255 = Math.round(mc.b * 255);
                                detectedColors.add(`RGB(${r255},${g255},${b255})`);
                                for (let i = 0; i < pos.count; i++) {
                                    colors.push(mc.r, mc.g, mc.b);
                                }
                                geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                            }
                        }
                    }
                    geometries.push(geom);
                }
            });

            log(`„É°„ÉÉ„Ç∑„É•Êï∞: ${meshCount}, „Éû„ÉÜ„É™„Ç¢„É´ÈÅ©Áî®Êï∞: ${materialCount}`);
            if (detectedColors.size > 0) {
                log(`Ê§úÂá∫„Åï„Çå„ÅüËâ≤: ${Array.from(detectedColors).join(', ')}`);
            }

            if (geometries.length === 0) throw new Error('No geometry found');
            if (geometries.length === 1) return geometries[0];

            const merged = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            let hasAnyColors = false;

            // „Åæ„ÅöËâ≤„ÇíÊåÅ„Å§„Ç∏„Ç™„É°„Éà„É™„Åå„ÅÇ„Çã„ÅãÁ¢∫Ë™ç
            for (const geom of geometries) {
                if (geom.getAttribute('color')) {
                    hasAnyColors = true;
                    break;
                }
            }

            for (const geom of geometries) {
                const pos = geom.getAttribute('position');
                const col = geom.getAttribute('color');
                if (pos) {
                    for (let i = 0; i < pos.count; i++) {
                        positions.push(pos.getX(i), pos.getY(i), pos.getZ(i));
                        if (hasAnyColors) {
                            if (col) {
                                colors.push(col.getX(i), col.getY(i), col.getZ(i));
                            } else {
                                colors.push(0.5, 0.5, 0.5); // Ëâ≤„Åå„Å™„ÅÑ„Ç∏„Ç™„É°„Éà„É™„ÅØ„Ç∞„É¨„Éº
                            }
                        }
                    }
                }
            }
            merged.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            if (hasAnyColors && colors.length > 0) {
                merged.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            }
            return merged;
        }

        // ========== Auto Resolution ==========
        function calculateOptimalResolution(geometry, maxVoxels = 100000) {
            geometry.computeBoundingBox();
            const bbox = geometry.boundingBox;
            const sizeX = Math.max(bbox.max.x - bbox.min.x, 0.001);
            const sizeY = Math.max(bbox.max.y - bbox.min.y, 0.001);
            const sizeZ = Math.max(bbox.max.z - bbox.min.z, 0.001);
            const maxDim = Math.max(sizeX, sizeY, sizeZ);
            const volume = Math.max(sizeX * sizeY * sizeZ, 0.000001);

            // Calculate resolution to achieve approximately maxVoxels
            // volume / resolution^3 ‚âà maxVoxels
            // resolution ‚âà (volume / maxVoxels)^(1/3)
            let optimalRes = Math.pow(volume / maxVoxels, 1 / 3);

            // Ensure reasonable bounds: min 0.01, max = maxDim/5 (at least 5 voxels per axis)
            optimalRes = Math.max(0.01, Math.min(optimalRes, maxDim / 5));

            // Round to 2 decimal places
            optimalRes = Math.round(optimalRes * 100) / 100;
            if (optimalRes < 0.01) optimalRes = 0.01;

            return {
                resolution: optimalRes,
                modelSize: { x: sizeX.toFixed(2), y: sizeY.toFixed(2), z: sizeZ.toFixed(2) },
                maxDim: maxDim.toFixed(2),
                estimatedVoxels: Math.floor(volume / Math.pow(optimalRes, 3))
            };
        }

        // ========== Color to Block Mapping ==========
        // „Ç´„ÉÜ„Ç¥„É™Âà•„Ç´„É©„Éº„Éë„É¨„ÉÉ„Éà
        const BLOCK_COLORS_WOOL = [
            { name: 'wool:white', r: 234, g: 236, b: 237 },
            { name: 'wool:orange', r: 241, g: 118, b: 20 },
            { name: 'wool:magenta', r: 190, g: 69, b: 180 },
            { name: 'wool:cyan', r: 22, g: 156, b: 157 },
            { name: 'wool:yellow', r: 254, g: 199, b: 31 },
            { name: 'wool:green', r: 112, g: 185, b: 26 },
            { name: 'wool:pink', r: 238, g: 141, b: 172 },
            { name: 'wool:grey', r: 63, g: 68, b: 72 },
            { name: 'wool:dark_grey', r: 142, g: 142, b: 135 },
            { name: 'wool:violet', r: 122, g: 42, b: 173 },
            { name: 'wool:blue', r: 53, g: 57, b: 157 },
            { name: 'wool:brown', r: 114, g: 72, b: 41 },
            { name: 'wool:dark_green', r: 84, g: 109, b: 28 },
            { name: 'wool:red', r: 161, g: 39, b: 35 },
            { name: 'wool:black', r: 21, g: 21, b: 26 },
        ];

        const BLOCK_COLORS_CONCRETE = [
            { name: 'concrete:concrete_white', r: 207, g: 213, b: 214 },
            { name: 'concrete:concrete_orange', r: 224, g: 97, b: 1 },
            { name: 'concrete:concrete_magenta', r: 170, g: 48, b: 159 },
            { name: 'concrete:concrete_cyan', r: 21, g: 119, b: 136 },
            { name: 'concrete:concrete_yellow', r: 241, g: 175, b: 21 },
            { name: 'concrete:concrete_green', r: 94, g: 169, b: 25 },
            { name: 'concrete:concrete_pink', r: 214, g: 101, b: 143 },
            { name: 'concrete:concrete_grey', r: 55, g: 58, b: 62 },
            { name: 'concrete:concrete_dark_grey', r: 125, g: 125, b: 115 },
            { name: 'concrete:concrete_violet', r: 100, g: 32, b: 156 },
            { name: 'concrete:concrete_blue', r: 45, g: 47, b: 143 },
            { name: 'concrete:concrete_brown', r: 96, g: 60, b: 32 },
            { name: 'concrete:concrete_dark_green', r: 73, g: 91, b: 36 },
            { name: 'concrete:concrete_red', r: 142, g: 33, b: 33 },
            { name: 'concrete:concrete_black', r: 8, g: 10, b: 15 },
        ];

        const BLOCK_COLORS_TERRACOTTA = [
            { name: 'hardened_clay:white', r: 210, g: 178, b: 161 },
            { name: 'hardened_clay:orange', r: 162, g: 84, b: 38 },
            { name: 'hardened_clay:magenta', r: 150, g: 88, b: 109 },
            { name: 'hardened_clay:cyan', r: 87, g: 91, b: 91 },
            { name: 'hardened_clay:yellow', r: 186, g: 133, b: 35 },
            { name: 'hardened_clay:green', r: 104, g: 118, b: 53 },
            { name: 'hardened_clay:pink', r: 162, g: 78, b: 79 },
            { name: 'hardened_clay:grey', r: 58, g: 42, b: 36 },
            { name: 'hardened_clay:dark_grey', r: 135, g: 107, b: 98 },
            { name: 'hardened_clay:violet', r: 118, g: 70, b: 86 },
            { name: 'hardened_clay:blue', r: 74, g: 60, b: 91 },
            { name: 'hardened_clay:brown', r: 77, g: 51, b: 36 },
            { name: 'hardened_clay:dark_green', r: 76, g: 83, b: 42 },
            { name: 'hardened_clay:red', r: 143, g: 61, b: 47 },
            { name: 'hardened_clay:black', r: 37, g: 23, b: 17 },
        ];

        const BLOCK_COLORS_GLASS = [
            { name: 'default:glass', r: 230, g: 230, b: 230 },
            { name: 'default:glass_white', r: 240, g: 240, b: 240 },
            { name: 'default:glass_orange', r: 255, g: 200, b: 100 },
            { name: 'default:glass_magenta', r: 200, g: 100, b: 200 },
            { name: 'default:glass_cyan', r: 127, g: 221, b: 212 },
            { name: 'default:glass_yellow', r: 255, g: 255, b: 150 },
            { name: 'default:glass_green', r: 173, g: 255, b: 47 },
            { name: 'default:glass_pink', r: 255, g: 182, b: 193 },
            { name: 'default:glass_grey', r: 150, g: 150, b: 150 },
            { name: 'default:glass_dark_grey', r: 80, g: 80, b: 80 },
            { name: 'default:glass_violet', r: 147, g: 112, b: 219 },
            { name: 'default:glass_blue', r: 107, g: 138, b: 201 },
            { name: 'default:glass_brown', r: 120, g: 80, b: 50 },
            { name: 'default:glass_dark_green', r: 50, g: 100, b: 50 },
            { name: 'default:glass_red', r: 200, g: 50, b: 50 },
            { name: 'default:glass_black', r: 30, g: 30, b: 30 },
        ];

        const BLOCK_COLORS_OTHER = [
            { name: 'default:stone', r: 125, g: 125, b: 125 },
            { name: 'default:cobble', r: 100, g: 100, b: 100 },
            { name: 'default:dirt', r: 134, g: 96, b: 67 },
            { name: 'default:sand', r: 219, g: 211, b: 160 },
            { name: 'default:gravel', r: 136, g: 126, b: 126 },
            { name: 'default:clay', r: 159, g: 164, b: 177 },
            { name: 'default:sandstone', r: 218, g: 210, b: 158 },
            { name: 'default:brick', r: 150, g: 97, b: 83 },
            { name: 'default:obsidian', r: 15, g: 11, b: 25 },
            { name: 'default:goldblock', r: 249, g: 236, b: 79 },
            { name: 'default:steelblock', r: 230, g: 230, b: 230 },
            { name: 'default:copperblock', r: 192, g: 108, b: 80 },
            { name: 'default:wood', r: 162, g: 131, b: 79 },
            { name: 'default:tree', r: 111, g: 91, b: 54 },
            { name: 'default:leaves', r: 58, g: 93, b: 40 },
            { name: 'default:ice', r: 175, g: 215, b: 253 },
            { name: 'default:snowblock', r: 249, g: 254, b: 254 },
            { name: 'default:quartz_block', r: 235, g: 230, b: 220 },
            { name: 'default:emeraldblock', r: 50, g: 200, b: 100 },
            { name: 'default:rubyblock', r: 200, g: 50, b: 80 },
            { name: 'default:diamondblock', r: 100, g: 220, b: 255 },
            { name: 'amethyst_geode:amethyst_block', r: 150, g: 100, b: 200 },
            { name: 'charoite:block', r: 140, g: 80, b: 180 },
            { name: 'bluestone_stickyblocks:slimeblock', r: 120, g: 200, b: 80 },
            { name: 'pink_biome:cherry_blossom_leaves', r: 255, g: 180, b: 200 },
            { name: 'pink_biome:cherry_blossom_wood', r: 180, g: 130, b: 120 },
        ];

        // „Åô„Åπ„Å¶„ÅÆ„Ç´„É©„Éº„Éñ„É≠„ÉÉ„ÇØ„ÇíÁµêÂêà
        const BLOCK_COLORS_ALL = [
            ...BLOCK_COLORS_WOOL,
            ...BLOCK_COLORS_CONCRETE,
            ...BLOCK_COLORS_TERRACOTTA,
            ...BLOCK_COLORS_GLASS,
            ...BLOCK_COLORS_OTHER,
        ];

        function getBlockColorPalette(mode) {
            switch (mode) {
                case 'wool': return BLOCK_COLORS_WOOL;
                case 'concrete': return BLOCK_COLORS_CONCRETE;
                case 'terracotta': return BLOCK_COLORS_TERRACOTTA;
                case 'glass': return BLOCK_COLORS_GLASS;
                case 'all': return BLOCK_COLORS_ALL;
                default: return [];
            }
        }

        function colorDistance(r1, g1, b1, r2, g2, b2) {
            // CIE76„Å´Ëøë‰ºº„Åó„ÅüËâ≤Â∑ÆË®àÁÆóÔºà‰∫∫Èñì„ÅÆÁõÆ„Å´Ëøë„ÅÑÔºâ
            const dr = r1 - r2, dg = g1 - g2, db = b1 - b2;
            // Ëµ§„ÅÆÈáç„Åø‰ªò„Åë„ÇíË™øÊï¥Ôºà‰∫∫Èñì„ÅÆÁõÆ„ÅØÁ∑ë„Å´ÊïèÊÑü„ÄÅÈùí„Å´ÈàçÊÑüÔºâ
            const rMean = (r1 + r2) / 2;
            const weightR = rMean < 128 ? 2 : 3;
            const weightG = 4;
            const weightB = rMean < 128 ? 3 : 2;
            return Math.sqrt(weightR * dr * dr + weightG * dg * dg + weightB * db * db);
        }

        function findNearestBlock(r, g, b, mode = 'all') {
            if (mode === 'single') {
                return document.getElementById('blockId').value || 'default:stone';
            }

            const palette = getBlockColorPalette(mode);
            if (palette.length === 0) {
                return document.getElementById('blockId').value || 'default:stone';
            }

            let minDist = Infinity;
            let nearest = palette[0].name;
            for (const block of palette) {
                const dist = colorDistance(r, g, b, block.r, block.g, block.b);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = block.name;
                }
            }
            return nearest;
        }

        // ÂæåÊñπ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅ
        function findNearestWool(r, g, b) {
            return findNearestBlock(r, g, b, 'all');
        }

        // ========== Voxelization ==========
        function voxelizeMesh(geometry, resolution, colorMode = 'all') {
            log(`„Éú„ÇØ„Çª„É´Âåñ‰∏≠ (Ëß£ÂÉèÂ∫¶: ${resolution}, Ëâ≤„É¢„Éº„Éâ: ${colorMode})...`);
            geometry.computeBoundingBox();
            const bbox = geometry.boundingBox;
            const minX = bbox.min.x, minY = bbox.min.y, minZ = bbox.min.z;
            const maxX = bbox.max.x, maxY = bbox.max.y, maxZ = bbox.max.z;
            const sizeX = Math.ceil((maxX - minX) / resolution);
            const sizeY = Math.ceil((maxY - minY) / resolution);
            const sizeZ = Math.ceil((maxZ - minZ) / resolution);
            log(`„Ç∞„É™„ÉÉ„Éâ„Çµ„Ç§„Ç∫: ${sizeX} x ${sizeY} x ${sizeZ}`);

            const positions = geometry.getAttribute('position');
            const colors = geometry.getAttribute('color'); // È†ÇÁÇπ„Ç´„É©„Éº„ÇíÂèñÂæó
            const hasColors = colors !== null && colors !== undefined;

            // Âçò‰∏Ä„Éñ„É≠„ÉÉ„ÇØ„É¢„Éº„Éâ„ÅÆÂ†¥Âêà„ÅØËâ≤ÊÉÖÂ†±„ÇíÁÑ°Ë¶ñ
            const useColors = hasColors && colorMode !== 'single';

            if (useColors) {
                const modeNames = {
                    'wool': '„Ç¶„Éº„É´',
                    'concrete': '„Ç≥„É≥„ÇØ„É™„Éº„Éà',
                    'hardened_clay': '„ÉÜ„É©„Ç≥„ÉÉ„Çø',
                    'glass': '„Ç¨„É©„Çπ',
                    'all': '„Åô„Åπ„Å¶„ÅÆ„Ç´„É©„Éº„Éñ„É≠„ÉÉ„ÇØ'
                };
                log(`È†ÇÁÇπ„Ç´„É©„Éº„ÇíÊ§úÂá∫ - ${modeNames[colorMode] || colorMode}„ÅßËâ≤‰ªò„Åë„Åó„Åæ„Åô`, 'success');
                // „Çµ„É≥„Éó„É´„Å®„Åó„Å¶ÊúÄÂàù„ÅÆÈ†ÇÁÇπ„ÅÆËâ≤„Çí„É≠„Ç∞Âá∫Âäõ
                if (colors.count > 0) {
                    const sampleR = Math.round(colors.getX(0) * 255);
                    const sampleG = Math.round(colors.getY(0) * 255);
                    const sampleB = Math.round(colors.getZ(0) * 255);
                    log(`„Çµ„É≥„Éó„É´Ëâ≤: RGB(${sampleR}, ${sampleG}, ${sampleB})`);
                }
            } else if (colorMode === 'single') {
                log('Âçò‰∏Ä„Éñ„É≠„ÉÉ„ÇØ„É¢„Éº„Éâ - ÊåáÂÆö„Åó„Åü„Éñ„É≠„ÉÉ„ÇØID„Çí‰ΩøÁî®„Åó„Åæ„Åô');
            } else {
                log('È†ÇÁÇπ„Ç´„É©„Éº„Å™„Åó - Âçò‰∏Ä„Éñ„É≠„ÉÉ„ÇØID„Çí‰ΩøÁî®„Åó„Åæ„Åô');
                // „Éá„Éê„ÉÉ„Ç∞: Âà©Áî®ÂèØËÉΩ„Å™Â±ûÊÄß„ÇíË°®Á§∫
                const attrs = Object.keys(geometry.attributes);
                log(`Âà©Áî®ÂèØËÉΩ„Å™Â±ûÊÄß: ${attrs.join(', ') || 'position „ÅÆ„Åø'}`);
            }

            const triangles = [];
            for (let i = 0; i < positions.count; i += 3) {
                const tri = {
                    v0: new THREE.Vector3(positions.getX(i), positions.getY(i), positions.getZ(i)),
                    v1: new THREE.Vector3(positions.getX(i + 1), positions.getY(i + 1), positions.getZ(i + 1)),
                    v2: new THREE.Vector3(positions.getX(i + 2), positions.getY(i + 2), positions.getZ(i + 2))
                };
                if (useColors) {
                    // ‰∏âËßíÂΩ¢„ÅÆÂπ≥ÂùáËâ≤„ÇíË®àÁÆó
                    tri.r = Math.round(((colors.getX(i) + colors.getX(i + 1) + colors.getX(i + 2)) / 3) * 255);
                    tri.g = Math.round(((colors.getY(i) + colors.getY(i + 1) + colors.getY(i + 2)) / 3) * 255);
                    tri.b = Math.round(((colors.getZ(i) + colors.getZ(i + 1) + colors.getZ(i + 2)) / 3) * 255);
                }
                triangles.push(tri);
            }
            log(`‰∏âËßíÂΩ¢Êï∞: ${triangles.length}`);

            const voxels = new Map(); // key -> { x, y, z, blockId }
            for (const tri of triangles) {
                const samples = sampleTriangle(tri.v0, tri.v1, tri.v2, resolution / 2);
                const blockId = useColors ? findNearestBlock(tri.r, tri.g, tri.b, colorMode) : null;
                for (const p of samples) {
                    const vx = Math.floor((p.x - minX) / resolution);
                    const vy = Math.floor((p.y - minY) / resolution);
                    const vz = Math.floor((p.z - minZ) / resolution);
                    const key = `${vx},${vy},${vz}`;
                    if (!voxels.has(key)) {
                        voxels.set(key, { x: vx, y: vy, z: vz, blockId: blockId });
                    }
                }
            }

            const result = [];
            for (const voxel of voxels.values()) {
                result.push([voxel.x, voxel.y, voxel.z, voxel.blockId]);
            }
            log(`„Éú„ÇØ„Çª„É´Êï∞: ${result.length}`, 'success');
            if (useColors) {
                const colorStats = {};
                for (const v of result) {
                    if (v[3]) colorStats[v[3]] = (colorStats[v[3]] || 0) + 1;
                }
                log(`‰ΩøÁî®„Éñ„É≠„ÉÉ„ÇØ: ${Object.keys(colorStats).join(', ')}`);
            }
            return result;
        }

        function sampleTriangle(v0, v1, v2, step) {
            const points = [];
            const edge1 = new THREE.Vector3().subVectors(v1, v0);
            const edge2 = new THREE.Vector3().subVectors(v2, v0);
            const cross = new THREE.Vector3().crossVectors(edge1, edge2);
            const area = cross.length() / 2;
            // Cap samples at 100 to prevent memory explosion on large triangles
            const numSamples = Math.min(100, Math.max(1, Math.ceil(area / (step * step))));
            for (let i = 0; i <= numSamples; i++) {
                for (let j = 0; j <= numSamples - i; j++) {
                    const u = i / numSamples, v = j / numSamples, w = 1 - u - v;
                    points.push(new THREE.Vector3(
                        w * v0.x + u * v1.x + v * v2.x,
                        w * v0.y + u * v1.y + v * v2.y,
                        w * v0.z + u * v1.z + v * v2.z
                    ));
                }
            }
            return points;
        }

        function generate3DModelCommands(voxels, defaultBlockId, scale = 1) {
            const commands = [];
            let pos = [0, 0, 0];
            let lastBlockId = null;
            const sorted = [...voxels].sort((a, b) => {
                if (a[1] !== b[1]) return a[1] - b[1];
                if (a[2] !== b[2]) return a[2] - b[2];
                return a[0] - b[0];
            });
            for (let i = 0; i < sorted.length; i++) {
                const [x, y, z, colorBlockId] = sorted[i];
                const blockId = colorBlockId || defaultBlockId;
                const axes = ['x', 'y', 'z'];
                const target = [x, y, z];
                for (let j = 0; j < 3; j++) {
                    const diff = Math.floor(target[j] * scale - pos[j] * scale);
                    if (diff !== 0) {
                        commands.push(`/shift ${axes[j]} ${diff}`);
                        pos[j] = target[j];
                    }
                }
                commands.push(`/s ${blockId}`);
                if (i % 1000 === 0) setProgress(Math.floor((i / sorted.length) * 100));
            }
            return commands;
        }

        // ========== Commands ==========
        function generateCommands(blocks, scale = 1) {
            const commands = [];
            let pos = [0, 0, 0];
            let skipped = 0;

            const sorted = [...blocks].sort((a, b) => {
                if (a[1] !== b[1]) return a[1] - b[1];
                if (a[2] !== b[2]) return a[2] - b[2];
                return a[0] - b[0];
            });

            for (let i = 0; i < sorted.length; i++) {
                const block = sorted[i];
                const [x, y, z, name] = block;

                let cmd, param2;
                if (isWorldEdit) {
                    // WorldEditÂΩ¢Âºè: „Ç´„Çπ„Çø„É†Â§âÊèõ„Çí„ÉÅ„Çß„ÉÉ„ÇØ„ÄÅ„Å™„Åë„Çå„Å∞„Åù„ÅÆ„Åæ„Åæ‰ΩøÁî®
                    let blockName = name;
                    if (!blockName.includes(':')) {
                        blockName = 'default:' + blockName;
                    }
                    // „Ç´„Çπ„Çø„É†Â§âÊèõ„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºàminecraft:„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÇÇË©¶„ÅôÔºâ
                    const minecraftName = 'minecraft:' + blockName.replace(/^[^:]+:/, '');
                    if (userMappings[blockName] !== undefined) {
                        cmd = userMappings[blockName];
                    } else if (userMappings[minecraftName] !== undefined) {
                        cmd = userMappings[minecraftName];
                    } else {
                        cmd = name;
                    }
                    param2 = block[4] || 0;
                } else {
                    // MinecraftÂΩ¢Âºè: „Éû„ÉÉ„Éî„É≥„Ç∞„ÇíÈÄö„Åô
                    [cmd, param2] = getMulticraftBlock(name);
                }
                if (cmd === null) { skipped++; continue; }

                const axes = ['x', 'y', 'z'];
                const target = [x, y, z];
                for (let j = 0; j < 3; j++) {
                    const diff = Math.floor(target[j] * scale - pos[j] * scale);
                    if (diff !== 0) {
                        commands.push(`/shift ${axes[j]} ${diff}`);
                        pos[j] = target[j];
                    }
                }
                commands.push(`/s ${cmd}`);
                if (param2 !== 0) commands.push(`/param2 ${param2}`);
                if (i % 1000 === 0) setProgress(Math.floor((i / sorted.length) * 100));
            }

            if (skipped > 0) log(`„Çπ„Ç≠„ÉÉ„Éó: ${skipped}`, 'warning');
            return commands;
        }

        // ========== Save ==========
        function saveCommands(commands, baseName) {
            const maxLines = parseInt(document.getElementById('maxLines').value) || 30000;
            downloadArea.innerHTML = '';

            if (commands.length > maxLines) {
                const n = Math.ceil(commands.length / maxLines);
                for (let i = 0; i < n; i++) {
                    const chunk = commands.slice(i * maxLines, Math.min((i + 1) * maxLines, commands.length));
                    createLink(chunk, `${baseName}_part${i + 1}.txt`);
                }
            } else {
                createLink(commands, `${baseName}.txt`);
            }
        }

        function createLink(commands, fileName) {
            const commandText = commands.join('\n');
            const blob = new Blob([commandText], { type: 'text/plain' });

            // „Ç≥„É≥„ÉÜ„Éä„Çí‰ΩúÊàê
            const item = document.createElement('div');
            item.className = 'download-item';

            // „Éò„ÉÉ„ÉÄ„ÉºÔºà„Éï„Ç°„Ç§„É´Âêç„Å®„Ç≥„Éû„É≥„ÉâÊï∞Ôºâ
            const header = document.createElement('div');
            header.className = 'download-item-header';
            header.textContent = `${fileName} (${commands.length}„Ç≥„Éû„É≥„Éâ)`;
            item.appendChild(header);

            // „Éú„Çø„É≥„Ç≥„É≥„ÉÜ„Éä
            const buttons = document.createElement('div');
            buttons.className = 'download-buttons';

            // „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„É™„É≥„ÇØ
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            link.className = 'download-link';
            link.textContent = '„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ';
            buttons.appendChild(link);

            // „Ç≥„Éî„Éº„Éú„Çø„É≥
            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn';
            copyBtn.textContent = '„Ç≥„Éî„Éº';
            copyBtn.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText(commandText);
                    copyBtn.textContent = '„Ç≥„Éî„ÉºÂÆå‰∫ÜÔºÅ';
                    copyBtn.classList.add('copied');
                    log(`„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü: ${fileName}`, 'success');
                    setTimeout(() => {
                        copyBtn.textContent = '„Ç≥„Éî„Éº';
                        copyBtn.classList.remove('copied');
                    }, 2000);
                } catch (err) {
                    log(`„Ç≥„Éî„ÉºÂ§±Êïó: ${err.message}`, 'error');
                }
            });
            buttons.appendChild(copyBtn);

            item.appendChild(buttons);

            // „Ç≥„Éû„É≥„Éâ„Éó„É¨„Éì„É•„Éº
            const preview = document.createElement('div');
            preview.className = 'command-preview';

            const previewHeader = document.createElement('div');
            previewHeader.className = 'command-preview-header';
            previewHeader.innerHTML = `
                <span class="command-preview-title">„Ç≥„Éû„É≥„Éâ„Éó„É¨„Éì„É•„Éº (${commands.length}Ë°å)</span>
                <span class="command-preview-toggle">‚ñº Â±ïÈñã</span>
            `;

            const previewContent = document.createElement('div');
            previewContent.className = 'command-preview-content collapsed';

            // „Ç≥„Éû„É≥„Éâ„ÇíÊßãÊñá„Éè„Ç§„É©„Ç§„Éà‰ªò„Åç„ÅßË°®Á§∫ÔºàÊúÄÂ§ß500Ë°åÔºâ
            const displayCommands = commands.slice(0, 500);
            previewContent.innerHTML = displayCommands.map(cmd => {
                let highlighted = cmd
                    .replace(/(\/shift)/g, '<span class="cmd-shift">$1</span>')
                    .replace(/(\/s\s)/g, '<span class="cmd-set">$1</span>')
                    .replace(/(\/param2\s+\d+)/g, '<span class="cmd-param">$1</span>');
                return `<span class="cmd-line">${highlighted}</span>`;
            }).join('') + (commands.length > 500 ? `<span class="cmd-line" style="color:#888">... ‰ªñ${commands.length - 500}Ë°å</span>` : '');

            previewHeader.addEventListener('click', () => {
                const isCollapsed = previewContent.classList.toggle('collapsed');
                previewHeader.querySelector('.command-preview-toggle').textContent = isCollapsed ? '‚ñº Â±ïÈñã' : '‚ñ≤ Êäò„Çä„Åü„Åü„ÇÄ';
            });

            preview.appendChild(previewHeader);
            preview.appendChild(previewContent);
            item.appendChild(preview);

            downloadArea.appendChild(item);
            log(`Ê∫ñÂÇôÂÆå‰∫Ü: ${fileName}`, 'success');
        }

        // ========== Unknown Blocks ==========
        // multicraft_items.js„ÅÆID„Çª„ÉÉ„Éà„Çí„Ç≠„É£„ÉÉ„Ç∑„É•
        const validMulticraftIds = new Set(allItems.map(item => item.id));

        function findUnknown(blocks) {
            const unknown = {};
            for (const b of blocks) {
                let [base] = parseBlockState(b[3].toLowerCase());
                if (!base.startsWith('minecraft:')) base = 'minecraft:' + base;
                if (BLOCK_MAPPING[base] === undefined && !unknown[base]) {
                    unknown[base] = blocks.filter(x => {
                        let [n] = parseBlockState(x[3].toLowerCase());
                        if (!n.startsWith('minecraft:')) n = 'minecraft:' + n;
                        return n === base;
                    }).length;
                }
            }
            return unknown;
        }

        // WorldEdit (.we) „Éï„Ç°„Ç§„É´Áî®„ÅÆÊú™ÂØæÂøú„Éñ„É≠„ÉÉ„ÇØÊ§úÂá∫
        // multicraft_items.js„Å´Â≠òÂú®„Åó„Å™„ÅÑ„Éñ„É≠„ÉÉ„ÇØID„ÇíÊ§úÂá∫
        function findUnknownWorldEdit(blocks) {
            const unknown = {};
            for (const b of blocks) {
                const name = b[3];
                // air„Éñ„É≠„ÉÉ„ÇØ„ÅØ„Çπ„Ç≠„ÉÉ„Éó
                if (name === 'air' || name.endsWith(':air')) continue;

                // multicraft_items.js„Å´Â≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                if (!validMulticraftIds.has(name) && !unknown[name]) {
                    unknown[name] = blocks.filter(x => x[3] === name).length;
                }
            }
            return unknown;
        }

        // WorldEditÁî®„ÅÆÊú™ÂØæÂøú„Éñ„É≠„ÉÉ„ÇØË°®Á§∫
        function renderUnknownBlocksWorldEdit(unknown) {
            if (Object.keys(unknown).length === 0) {
                unknownList.innerHTML = '<div class="empty-state">Êú™ÂØæÂøú„Éñ„É≠„ÉÉ„ÇØ„Å™„Åó</div>';
                return;
            }

            const sorted = Object.entries(unknown).sort((a, b) => b[1] - a[1]);
            unknownList.innerHTML = sorted.map(([name, count]) => {
                return `
                <div class="unknown-item">
                    <div>
                        <div class="unknown-name">${name}</div>
                        <div class="unknown-count">${count}ÂÄã</div>
                    </div>
                    <div class="autocomplete-wrapper">
                        <input type="text" class="unknown-input" data-block="${name}" placeholder="Â§âÊèõÂÖà„ÇíÂÖ•Âäõ">
                        <div class="autocomplete-list"></div>
                    </div>
                </div>
            `;
            }).join('');

            unknownList.querySelectorAll('.unknown-input').forEach(setupAutocomplete);
        }


        function renderUnknownBlocks(unknown) {
            if (Object.keys(unknown).length === 0) {
                unknownList.innerHTML = '<div class="empty-state">Êú™ÂØæÂøú„Éñ„É≠„ÉÉ„ÇØ„Å™„Åó</div>';
                return;
            }

            const sorted = Object.entries(unknown).sort((a, b) => b[1] - a[1]);
            unknownList.innerHTML = sorted.map(([name, count]) => {
                const fallback = name.replace('minecraft:', 'default:');
                return `
                <div class="unknown-item">
                    <div>
                        <div class="unknown-name">${name}</div>
                        <div class="unknown-count">${count}ÂÄã</div>
                    </div>
                    <div class="autocomplete-wrapper">
                        <input type="text" class="unknown-input" data-block="${name}" placeholder="${fallback}">
                        <div class="autocomplete-list"></div>
                    </div>
                </div>
            `;
            }).join('');

            unknownList.querySelectorAll('.unknown-input').forEach(setupAutocomplete);
        }

        function collectMappings() {
            userMappings = {};
            for (const input of unknownList.querySelectorAll('.unknown-input')) {
                const name = input.dataset.block;
                const val = input.value.trim();
                if (val === '') {
                    // WorldEdit„Éï„Ç°„Ç§„É´„ÅÆÂ†¥Âêà„ÅØÂÖÉ„ÅÆ„Éñ„É≠„ÉÉ„ÇØID„Çí„Åù„ÅÆ„Åæ„Åæ‰Ωø„ÅÜ
                    // Minecraft„Éï„Ç°„Ç§„É´„ÅÆÂ†¥Âêà„ÅØminecraft:„Çídefault:„Å´ÁΩÆÊèõ
                    if (isWorldEdit) {
                        userMappings[name] = name;
                    } else {
                        userMappings[name] = name.replace('minecraft:', 'default:');
                    }
                }
                else if (val.toLowerCase() === 'air') userMappings[name] = null;
                else userMappings[name] = val;
            }

            // „Ç´„Çπ„Çø„É†Â§âÊèõ„Éû„ÉÉ„Éî„É≥„Ç∞„ÇíÁµ±ÂêàÔºàÂÑ™ÂÖàÂ∫¶È´ò„ÅÑÔºâ
            const customMappings = collectCustomMappings();
            if (customMappings === null) {
                return false; // ÈáçË§á„Ç®„É©„Éº
            }
            Object.assign(userMappings, customMappings);
            return true;
        }

        // ========== Export/Import Unknown Blocks ==========
        const exportUnknownBtn = document.getElementById('exportUnknownBtn');
        const importUnknownBtn = document.getElementById('importUnknownBtn');
        const importModal = document.getElementById('importModal');
        const importModalClose = document.getElementById('importModalClose');
        const importCancelBtn = document.getElementById('importCancelBtn');
        const importApplyBtn = document.getElementById('importApplyBtn');
        const importTextarea = document.getElementById('importTextarea');

        // „Ç®„ÇØ„Çπ„Éù„Éº„Éà: Êú™ÂØæÂøú„Éñ„É≠„ÉÉ„ÇØ‰∏ÄË¶ß„Çí„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº
        exportUnknownBtn.addEventListener('click', async () => {
            const inputs = unknownList.querySelectorAll('.unknown-input');
            if (inputs.length === 0) {
                log('„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åô„ÇãÊú™ÂØæÂøú„Éñ„É≠„ÉÉ„ÇØ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì', 'warning');
                return;
            }

            const lines = [];
            for (const input of inputs) {
                const source = input.dataset.block;
                const target = input.value.trim();
                if (target) {
                    lines.push(`${source} -> ${target}`);
                } else {
                    lines.push(`${source} -> `);
                }
            }

            const text = lines.join('\n');
            try {
                await navigator.clipboard.writeText(text);
                log(`${inputs.length}ÂÄã„ÅÆÊú™ÂØæÂøú„Éñ„É≠„ÉÉ„ÇØ„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü`, 'success');
                exportUnknownBtn.textContent = '‚úì';
                setTimeout(() => { exportUnknownBtn.textContent = 'üìã'; }, 1500);
            } catch (err) {
                log(`„Ç≥„Éî„ÉºÂ§±Êïó: ${err.message}`, 'error');
            }
        });

        // „Ç§„É≥„Éù„Éº„Éà„É¢„Éº„ÉÄ„É´„ÇíÈñã„Åè
        importUnknownBtn.addEventListener('click', () => {
            importTextarea.value = '';
            importModal.classList.add('active');
        });

        // „Ç§„É≥„Éù„Éº„Éà„É¢„Éº„ÉÄ„É´„ÇíÈñâ„Åò„Çã
        function closeImportModal() {
            importModal.classList.remove('active');
        }
        importModalClose.addEventListener('click', closeImportModal);
        importCancelBtn.addEventListener('click', closeImportModal);
        importModal.addEventListener('click', (e) => {
            if (e.target === importModal) closeImportModal();
        });

        // „Ç§„É≥„Éù„Éº„Éà„ÇíÈÅ©Áî®
        importApplyBtn.addEventListener('click', () => {
            const text = importTextarea.value;
            const lines = text.split('\n');
            let appliedCount = 0;

            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed) continue;

                // "source -> target" ÂΩ¢Âºè„Çí„Éë„Éº„Çπ
                const match = trimmed.match(/^(.+?)\s*->\s*(.*)$/);
                if (!match) continue;

                const source = match[1].trim();
                const target = match[2].trim();

                // Ë©≤ÂΩì„Åô„ÇãÂÖ•ÂäõÊ¨Ñ„ÇíÊé¢„Åó„Å¶ÂÄ§„ÇíË®≠ÂÆö
                const input = unknownList.querySelector(`.unknown-input[data-block="${source}"]`);
                if (input) {
                    input.value = target;
                    appliedCount++;
                }
            }

            closeImportModal();
            if (appliedCount > 0) {
                log(`${appliedCount}ÂÄã„ÅÆÂ§âÊèõÂÖà„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„Åæ„Åó„Åü`, 'success');
            } else {
                log('„Ç§„É≥„Éù„Éº„Éà„Åô„ÇãÂ§âÊèõÂÖà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü', 'warning');
            }
        });

        // ========== Custom Convert ==========
        // Ë™≠„ÅøËæº„Çì„Å†„Éñ„É≠„ÉÉ„ÇØ„ÅÆ„É™„Çπ„ÉàÔºàÂ§âÊèõÂÖÉ„Ç™„Éº„Éà„Ç≥„É≥„Éó„É™„Éº„ÉàÁî®Ôºâ
        let loadedBlocks = [];

        customConvertCheckbox.addEventListener('change', () => {
            customConvertEnabled = customConvertCheckbox.checked;
            const display = customConvertEnabled ? 'block' : 'none';
            customConvertHint.style.display = display;
            customConvertList.style.display = display;
            customConvertAddBtn.style.display = display;

            if (customConvertEnabled && customConvertEntries.length === 0) {
                addCustomConvertEntry();
            }
        });

        customConvertAddBtn.addEventListener('click', () => {
            addCustomConvertEntry();
        });

        // Â§âÊèõÂÖÉÁî®„Ç™„Éº„Éà„Ç≥„É≥„Éó„É™„Éº„ÉàÔºàË™≠„ÅøËæº„Çì„Å†„Éï„Ç°„Ç§„É´„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„Åã„ÇâÔºâ
        function setupSourceAutocomplete(input) {
            const wrapper = input.parentElement;
            const list = wrapper.querySelector('.autocomplete-list');

            input.addEventListener('input', () => {
                const val = input.value.toLowerCase();
                if (val.length < 1) {
                    list.classList.remove('visible');
                    return;
                }

                const matches = loadedBlocks.filter(block =>
                    block.toLowerCase().includes(val)
                ).slice(0, 10);

                if (matches.length === 0) {
                    list.classList.remove('visible');
                    return;
                }

                list.innerHTML = matches.map(block => `
                    <div class="autocomplete-item" data-id="${block}">
                        <div class="item-id">${block}</div>
                    </div>
                `).join('');

                list.classList.add('visible');
            });

            list.addEventListener('click', (e) => {
                const item = e.target.closest('.autocomplete-item');
                if (item) {
                    input.value = item.dataset.id;
                    list.classList.remove('visible');
                }
            });

            input.addEventListener('blur', () => {
                setTimeout(() => list.classList.remove('visible'), 200);
            });
        }

        function addCustomConvertEntry() {
            const entryId = Date.now();
            customConvertEntries.push(entryId);

            const entryHTML = `
            <div class="custom-convert-entry" data-entry-id="${entryId}">
                <div class="autocomplete-wrapper">
                    <input type="text" class="unknown-input custom-convert-from" placeholder="Â§âÊèõÂÖÉ„Éñ„É≠„ÉÉ„ÇØ">
                    <div class="autocomplete-list"></div>
                </div>
                <span class="custom-convert-arrow">‚Üí</span>
                <div class="autocomplete-wrapper">
                    <input type="text" class="unknown-input custom-convert-to" placeholder="Â§âÊèõÂÖà„Éñ„É≠„ÉÉ„ÇØ">
                    <div class="autocomplete-list"></div>
                </div>
                <button class="custom-convert-remove-btn" data-remove-id="${entryId}">√ó</button>
            </div>
            `;

            customConvertList.insertAdjacentHTML('beforeend', entryHTML);

            // „Ç™„Éº„Éà„Ç≥„É≥„Éó„É™„Éº„Éà„ÇíË®≠ÂÆö
            const entry = customConvertList.querySelector(`[data-entry-id="${entryId}"]`);
            // Â§âÊèõÂÖÉ„ÅØË™≠„ÅøËæº„Çì„Å†„Éñ„É≠„ÉÉ„ÇØ„Åã„Çâ
            setupSourceAutocomplete(entry.querySelector('.custom-convert-from'));
            // Â§âÊèõÂÖà„ÅØMulticraft„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„Åã„Çâ
            setupAutocomplete(entry.querySelector('.custom-convert-to'));

            // ÂâäÈô§„Éú„Çø„É≥„ÅÆ„Ç§„Éô„É≥„Éà
            entry.querySelector('.custom-convert-remove-btn').addEventListener('click', function () {
                removeCustomConvertEntry(parseInt(this.dataset.removeId));
            });
        }

        function removeCustomConvertEntry(entryId) {
            const entry = customConvertList.querySelector(`[data-entry-id="${entryId}"]`);
            if (entry) entry.remove();
            customConvertEntries = customConvertEntries.filter(id => id !== entryId);
        }

        // Ë™≠„ÅøËæº„Çì„Å†„Éñ„É≠„ÉÉ„ÇØ„É™„Çπ„Éà„ÇíÊõ¥Êñ∞
        function updateLoadedBlocks(blocks) {
            const blockSet = new Set();
            for (const b of blocks) {
                let [base] = parseBlockState(b[3].toLowerCase());
                if (!base.startsWith('minecraft:') && !base.includes(':')) {
                    base = 'minecraft:' + base;
                }
                blockSet.add(base);
            }
            loadedBlocks = Array.from(blockSet).sort();
        }

        // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ‰ªò„Åç„ÅÆcollectCustomMappings
        function collectCustomMappings() {
            if (!customConvertEnabled) return {};

            const mappings = {};
            const duplicates = [];
            const entries = customConvertList.querySelectorAll('.custom-convert-entry');

            for (const entry of entries) {
                const fromInput = entry.querySelector('.custom-convert-from');
                const toInput = entry.querySelector('.custom-convert-to');

                const from = fromInput.value.trim();
                const to = toInput.value.trim();

                // „Ç®„É©„Éº„Çπ„Çø„Ç§„É´„Çí„É™„Çª„ÉÉ„Éà
                fromInput.style.borderColor = '';

                if (from) {
                    // minecraft: „Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÇíÊ≠£Ë¶èÂåñ
                    let normalizedFrom = from;
                    if (!normalizedFrom.includes(':')) {
                        normalizedFrom = 'minecraft:' + normalizedFrom;
                    }

                    // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
                    if (mappings.hasOwnProperty(normalizedFrom)) {
                        duplicates.push(from);
                        fromInput.style.borderColor = '#d44';
                        continue;
                    }

                    if (to === '') {
                        // Â§âÊèõÂÖà„ÅåÁ©∫„ÅÆÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„ÉóÔºàÂ§âÊèõ„Åó„Å™„ÅÑÔºâ
                        continue;
                    } else if (to.toLowerCase() === 'air') {
                        mappings[normalizedFrom] = null;
                    } else {
                        mappings[normalizedFrom] = to;
                    }
                }
            }

            if (duplicates.length > 0) {
                log(`„Ç®„É©„Éº: Â§âÊèõÂÖÉ„ÅåÈáçË§á„Åó„Å¶„ÅÑ„Åæ„Åô: ${duplicates.join(', ')}`, 'error');
                return null; // „Ç®„É©„ÉºÊôÇ„ÅØnull„ÇíËøî„Åô
            }

            return mappings;
        }

        // ========== Process ==========
        async function processFiles(files) {
            // Ë§áÊï∞„Éï„Ç°„Ç§„É´„ÅÆÂ†¥ÂêàÔºàOBJ+MTLÔºâ„ÇíÂá¶ÁêÜ
            const fileList = Array.from(files);
            let objFile = null;
            let mtlFile = null;
            let otherFile = null;

            for (const file of fileList) {
                const ext = file.name.split('.').pop().toLowerCase();
                if (ext === 'obj') objFile = file;
                else if (ext === 'mtl') mtlFile = file;
                else otherFile = file;
            }

            // MTL„Éï„Ç°„Ç§„É´„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÂÖà„Å´Ë™≠„ÅøËæº„ÇÄ
            if (mtlFile) {
                log(`MTL„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø: ${mtlFile.name}`);
                const mtlText = await mtlFile.text();
                pendingMtlContent = mtlText;
            }

            // „É°„Ç§„É≥„Éï„Ç°„Ç§„É´„ÇíÂá¶ÁêÜ
            const mainFile = objFile || otherFile || fileList[0];
            if (mainFile) {
                await processFile(mainFile);
            }
        }

        async function processFile(file) {
            try {
                userResolutionLocked = false;
                currentGeometry = null;
                isWorldEdit = false;
                currentFileName = file.name;
                const ext = file.name.split('.').pop().toLowerCase();
                log(`Ë™≠„ÅøËæº„Åø: ${file.name}`);
                updateStatus('fileName', file.name);
                setProgress(0);

                if (['obj', 'stl'].includes(ext)) {
                    is3DModel = true;
                    log('3D„É¢„Éá„É´„ÇíË™≠„ÅøËæº„Åø‰∏≠...', 'success');
                    const geometry = await load3DModel(file);
                    currentGeometry = geometry;

                    // Calculate optimal resolution based on model size
                    const autoRes = calculateOptimalResolution(geometry);
                    log(`„É¢„Éá„É´„Çµ„Ç§„Ç∫: ${autoRes.modelSize.x} x ${autoRes.modelSize.y} x ${autoRes.modelSize.z}`);
                    log(`Êé®Â•®Ëß£ÂÉèÂ∫¶: ${autoRes.resolution} (Êé®ÂÆö„Éú„ÇØ„Çª„É´Êï∞: ${autoRes.estimatedVoxels.toLocaleString()})`);

                    const resInput = resolutionInput;
                    if (!userResolutionLocked) {
                        // Refresh to the auto value for each new file unless the user explicitly typed a value
                        resInput.value = autoRes.resolution;
                    }

                    const userRes = parseFloat(resInput.value);
                    let resolution = autoRes.resolution;
                    if (userResolutionLocked && userRes && userRes > 0) {
                        const bbox = geometry.boundingBox;
                        const estVoxels = ((bbox.max.x - bbox.min.x) / userRes) *
                            ((bbox.max.y - bbox.min.y) / userRes) *
                            ((bbox.max.z - bbox.min.z) / userRes);
                        if (estVoxels > 500000) {
                            log(`Ë≠¶Âëä: „É¶„Éº„Ç∂„ÉºË®≠ÂÆö„ÅÆËß£ÂÉèÂ∫¶ ${userRes} „Å†„Å®Á¥Ñ${Math.floor(estVoxels).toLocaleString()}„Éú„ÇØ„Çª„É´„Å´„Å™„Çä„Åæ„Åô`, 'warning');
                            log(`Ëá™ÂãïË™øÊï¥„Åï„Çå„ÅüËß£ÂÉèÂ∫¶ ${autoRes.resolution} „Çí‰ΩøÁî®„Åó„Åæ„Åô`, 'warning');
                        } else {
                            resolution = userRes;
                        }
                    }

                    // Update UI with actual resolution used for this file
                    resInput.value = resolution;

                    // È†ÇÁÇπ„Ç´„É©„Éº„ÅÆÊúâÁÑ°„ÇíËá™ÂãïÊ§úÂá∫„Åó„Å¶„Ç´„É©„Éº„É¢„Éº„Éâ„ÇíË®≠ÂÆö
                    const colors = geometry.getAttribute('color');
                    const hasVertexColors = colors !== null && colors !== undefined;
                    const colorModeSelect = document.getElementById('colorMode');

                    // „Ç´„É©„Éº„Éñ„É≠„ÉÉ„ÇØ„Ç™„Éó„Ç∑„Éß„É≥„ÅÆÊúâÂäπ/ÁÑ°Âäπ„ÇíÂàá„ÇäÊõø„Åà
                    const colorOptions = colorModeSelect.querySelectorAll('option');
                    colorOptions.forEach(option => {
                        if (option.value !== 'single') {
                            option.disabled = !hasVertexColors;
                        }
                    });

                    if (hasVertexColors) {
                        // È†ÇÁÇπ„Ç´„É©„Éº„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Äå„Åô„Åπ„Å¶„ÅÆ„Ç´„É©„Éº„Éñ„É≠„ÉÉ„ÇØ„Äç„ÇíÈÅ∏Êäû
                        colorModeSelect.value = 'all';
                        blockIdGroup.style.display = 'none';
                        log('È†ÇÁÇπ„Ç´„É©„Éº„ÇíÊ§úÂá∫ - „Ç´„É©„Éº„Éñ„É≠„ÉÉ„ÇØ„É¢„Éº„Éâ„ÇíËá™ÂãïÈÅ∏Êäû', 'success');
                    } else {
                        // È†ÇÁÇπ„Ç´„É©„Éº„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄåÂçò‰∏Ä„Éñ„É≠„ÉÉ„ÇØ„Äç„ÇíÈÅ∏Êäû
                        colorModeSelect.value = 'single';
                        blockIdGroup.style.display = 'block';
                        log('È†ÇÁÇπ„Ç´„É©„Éº„Å™„Åó - Âçò‰∏Ä„Éñ„É≠„ÉÉ„ÇØ„É¢„Éº„Éâ„ÇíËá™ÂãïÈÅ∏Êäû');
                    }

                    const colorMode = colorModeSelect.value;
                    current3DVoxels = voxelizeMesh(geometry, resolution, colorMode);
                    currentBlocks = [];
                    updateStatus('blockCount', current3DVoxels.length);
                    update3DSettingsVisibility();
                    convertBtn.disabled = false;
                    previewBtn.disabled = false;
                } else if (ext === 'we') {
                    // WorldEditÂΩ¢Âºè
                    is3DModel = false;
                    isWorldEdit = true;
                    update3DSettingsVisibility();
                    const text = await file.text();
                    currentBlocks = loadWorldEdit(text);
                    current3DVoxels = [];
                    updateStatus('blockCount', currentBlocks.length);
                    log(`WorldEdit„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø: ${currentBlocks.length}„Éñ„É≠„ÉÉ„ÇØ`, 'success');
                    // WorldEditÂΩ¢Âºè„ÅØmulticraft_items.js„Å´Â≠òÂú®„Åó„Å™„ÅÑ„Éñ„É≠„ÉÉ„ÇØ„ÇíÊú™ÂØæÂøú„Å®„Åô„Çã
                    unknownBlocks = findUnknownWorldEdit(currentBlocks);
                    if (Object.keys(unknownBlocks).length > 0) {
                        renderUnknownBlocksWorldEdit(unknownBlocks);
                        log(`Êú™ÂØæÂøú: ${Object.keys(unknownBlocks).length}Á®ÆÈ°û`, 'warning');
                    }
                    updateSettingsVisibility();
                    updateLoadedBlocks(currentBlocks);
                    convertBtn.disabled = false;
                    previewBtn.disabled = false;
                } else if (ext === 'schem') {
                    // Sponge Schematic (.schem)
                    is3DModel = false;
                    isWorldEdit = false;
                    update3DSettingsVisibility();
                    const buf = await file.arrayBuffer();
                    let data;
                    try { data = pako.inflate(new Uint8Array(buf)); }
                    catch { data = new Uint8Array(buf); }

                    try {
                        currentBlocks = loadSchem(data);
                        current3DVoxels = [];
                        updateStatus('blockCount', currentBlocks.length);
                        log(`Schematic„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø: ${currentBlocks.length}„Éñ„É≠„ÉÉ„ÇØ`, 'success');
                        unknownBlocks = findUnknown(currentBlocks);
                        if (Object.keys(unknownBlocks).length > 0) {
                            renderUnknownBlocks(unknownBlocks);
                            log(`Êú™ÂØæÂøú: ${Object.keys(unknownBlocks).length}Á®ÆÈ°û`, 'warning');
                            updateSettingsVisibility();
                        }
                        updateLoadedBlocks(currentBlocks);
                        convertBtn.disabled = false;
                        previewBtn.disabled = false;
                    } catch (e) {
                        log(`SchematicË™≠„ÅøËæº„Åø„Ç®„É©„Éº: ${e.message}`, 'error');
                        throw e;
                    }
                } else {
                    is3DModel = false;
                    isWorldEdit = false;
                    update3DSettingsVisibility();
                    const buf = await file.arrayBuffer();
                    let data;
                    try { data = pako.inflate(new Uint8Array(buf)); }
                    catch { data = new Uint8Array(buf); }
                    currentBlocks = loadNBT(data);
                    current3DVoxels = [];
                    updateStatus('blockCount', currentBlocks.length);
                    log(`„Éñ„É≠„ÉÉ„ÇØ: ${currentBlocks.length}`, 'success');
                    unknownBlocks = findUnknown(currentBlocks);

                    // Êú™ÂØæÂøú„Éñ„É≠„ÉÉ„ÇØ„Åå„ÅÇ„Çå„Å∞„É¢„Éº„ÉÄ„É´„ÇíË°®Á§∫
                    if (Object.keys(unknownBlocks).length > 0) {
                        renderUnknownBlocks(unknownBlocks);
                        log(`Êú™ÂØæÂøú: ${Object.keys(unknownBlocks).length}Á®ÆÈ°û`, 'warning');
                        updateSettingsVisibility();
                    }
                    updateLoadedBlocks(currentBlocks);
                    convertBtn.disabled = false;
                    previewBtn.disabled = false;
                }
            } catch (e) {
                log(`„Ç®„É©„Éº: ${e.message}`, 'error');
                console.error(e);
            }
        }

        function doConvert() {
            const scale = parseInt(document.getElementById('scale').value) || 1;
            let commands;
            if (is3DModel) {
                if (!currentGeometry) {
                    log('3D„É¢„Éá„É´„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì', 'error');
                    return;
                }

                // Recalculate resolution at conversion time in case the user edited the value after load
                const autoRes = calculateOptimalResolution(currentGeometry);
                const resInput = resolutionInput;
                if (!userResolutionLocked) {
                    resInput.value = autoRes.resolution;
                }

                const userRes = parseFloat(resInput.value);
                let resolution = autoRes.resolution;
                if (userRes && userRes > 0) {
                    if (!currentGeometry.boundingBox) currentGeometry.computeBoundingBox();
                    const bbox = currentGeometry.boundingBox;
                    const estVoxels = ((bbox.max.x - bbox.min.x) / userRes) *
                        ((bbox.max.y - bbox.min.y) / userRes) *
                        ((bbox.max.z - bbox.min.z) / userRes);
                    if (estVoxels > 500000) {
                        log(`Ë≠¶Âëä: „É¶„Éº„Ç∂„ÉºË®≠ÂÆö„ÅÆËß£ÂÉèÂ∫¶ ${userRes} „Å†„Å®Á¥Ñ${Math.floor(estVoxels).toLocaleString()}„Éú„ÇØ„Çª„É´„Å´„Å™„Çä„Åæ„Åô`, 'warning');
                        log(`Ëá™ÂãïË™øÊï¥„Åï„Çå„ÅüËß£ÂÉèÂ∫¶ ${autoRes.resolution} „Çí‰ΩøÁî®„Åó„Åæ„Åô`, 'warning');
                    } else {
                        resolution = userRes;
                    }
                }
                resInput.value = resolution;

                const colorMode = document.getElementById('colorMode').value;
                current3DVoxels = voxelizeMesh(currentGeometry, resolution, colorMode);
                updateStatus('blockCount', current3DVoxels.length);

                const blockId = document.getElementById('blockId').value || 'default:stone';
                commands = generate3DModelCommands(current3DVoxels, blockId, scale);
            } else {
                if (!collectMappings()) {
                    return; // ÈáçË§á„Ç®„É©„Éº„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ‰∏≠Ê≠¢
                }
                commands = generateCommands(currentBlocks, scale);
            }
            updateStatus('commandCount', commands.length);
            setProgress(100);
            saveCommands(commands, currentFileName.replace(/\.[^.]+$/, ''));
            log(`ÂÆå‰∫Ü: ${commands.length}„Ç≥„Éû„É≥„Éâ`, 'success');
        }

        // ========== Events ==========
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', e => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                processFiles(e.dataTransfer.files);
            }
        });
        fileInput.addEventListener('change', e => {
            if (e.target.files.length > 0) {
                processFiles(e.target.files);
            }
        });
        convertBtn.addEventListener('click', doConvert);

        // ========== 3D Preview ==========
        const previewBtn = document.getElementById('previewBtn');
        const previewModal = document.getElementById('previewModal');
        const previewClose = document.getElementById('previewClose');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewInfo = document.getElementById('previewInfo');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const toggleWireBtn = document.getElementById('toggleWireBtn');

        let previewScene, previewCamera, previewRenderer, previewMesh;
        let previewCtrl = { drag: false, lx: 0, ly: 0, rx: 0.5, ry: 0.5, zoom: 1 };
        let wireMode = false, animId = null;

        function initPreview() {
            previewScene = new THREE.Scene();
            previewScene.background = new THREE.Color(0x1a1a1a);
            const c = previewCanvas.parentElement;
            previewCamera = new THREE.PerspectiveCamera(60, c.clientWidth / c.clientHeight, 0.1, 10000);
            previewCamera.position.set(0, 0, 100);
            previewRenderer = new THREE.WebGLRenderer({ canvas: previewCanvas, antialias: true });
            previewRenderer.setSize(c.clientWidth, c.clientHeight);
            previewRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            previewScene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const d1 = new THREE.DirectionalLight(0xffffff, 0.6); d1.position.set(1, 1, 1); previewScene.add(d1);
            const d2 = new THREE.DirectionalLight(0xffffff, 0.3); d2.position.set(-1, -1, -1); previewScene.add(d2);
        }

        function createVoxels(vox, isNBT) {
            if (previewMesh) { previewScene.remove(previewMesh); previewMesh.geometry?.dispose(); previewMesh.material?.dispose(); }
            if (!vox.length) return;
            let mnX = Infinity, mnY = Infinity, mnZ = Infinity, mxX = -Infinity, mxY = -Infinity, mxZ = -Infinity;
            for (const v of vox) {
                const x = v[0], y = v[1], z = v[2];
                mnX = Math.min(mnX, x); mxX = Math.max(mxX, x);
                mnY = Math.min(mnY, y); mxY = Math.max(mxY, y);
                mnZ = Math.min(mnZ, z); mxZ = Math.max(mxZ, z);
            }
            const cx = (mnX + mxX) / 2, cy = (mnY + mxY) / 2, cz = (mnZ + mxZ) / 2, sz = Math.max(mxX - mnX, mxY - mnY, mxZ - mnZ) + 1;
            const geo = new THREE.BoxGeometry(0.95, 0.95, 0.95);

            // Check if any voxel has color data (blockId) - only for 3D models
            const hasColorData = !isNBT && vox.some(v => v[3] !== null && v[3] !== undefined);

            let mat, mesh;
            if (hasColorData) {
                // Use instance colors for colored voxels
                mat = new THREE.MeshLambertMaterial({ wireframe: wireMode });
                mesh = new THREE.InstancedMesh(geo, mat, vox.length);

                const m = new THREE.Matrix4();
                const colors = [];
                for (let i = 0; i < vox.length; i++) {
                    const v = vox[i];
                    const x = v[0], y = v[1], z = v[2], blockId = v[3];
                    m.setPosition(x - cx, y - cy, z - cz);
                    mesh.setMatrixAt(i, m);

                    // Find color from blockId
                    let r = 0.3, g = 0.5, b = 0.8; // Default blue
                    if (blockId) {
                        const block = BLOCK_COLORS_ALL.find(bc => bc.name === blockId);
                        if (block) {
                            r = block.r / 255;
                            g = block.g / 255;
                            b = block.b / 255;
                        }
                    }
                    colors.push(r, g, b);
                }
                // Set instance colors using InstancedBufferAttribute
                mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(colors), 3);
                mesh.instanceColor.needsUpdate = true;
                mat.needsUpdate = true;
            } else {
                // Single color for NBT or non-colored 3D models
                mat = new THREE.MeshLambertMaterial({ color: 0x4a90d9, wireframe: wireMode });
                mesh = new THREE.InstancedMesh(geo, mat, vox.length);
                const m = new THREE.Matrix4();
                for (let i = 0; i < vox.length; i++) {
                    const v = vox[i];
                    const x = v[0], y = v[1], z = v[2];
                    m.setPosition(x - cx, y - cy, z - cz);
                    mesh.setMatrixAt(i, m);
                }
            }

            mesh.instanceMatrix.needsUpdate = true;
            previewScene.add(mesh); previewMesh = mesh;
            previewCamera.position.set(0, 0, sz * 1.5); previewCamera.lookAt(0, 0, 0);
            previewCtrl.zoom = 1; previewCtrl.rx = 0.5; previewCtrl.ry = 0.5;
            previewInfo.textContent = `${vox.length.toLocaleString()} „Éú„ÇØ„Çª„É´ | ${Math.ceil(mxX - mnX + 1)}x${Math.ceil(mxY - mnY + 1)}x${Math.ceil(mxZ - mnZ + 1)}`;
        }

        function renderLoop() {
            if (!previewMesh) return;
            previewMesh.rotation.x = previewCtrl.ry * Math.PI;
            previewMesh.rotation.y = previewCtrl.rx * Math.PI;
            previewRenderer.render(previewScene, previewCamera);
            animId = requestAnimationFrame(renderLoop);
        }

        function openPreview() {
            if (!previewScene) initPreview();
            const vox = is3DModel ? current3DVoxels : currentBlocks;
            if (!vox.length) { log('„Éó„É¨„Éì„É•„Éº„Åô„Çã„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì', 'error'); return; }
            const maxVox = 100000;
            let pv = vox.length > maxVox ? (log(`„Éó„É¨„Éì„É•„Éº„Çí${maxVox}„Å´Âà∂Èôê`, 'warning'), vox.slice(0, maxVox)) : vox;
            createVoxels(pv, !is3DModel);
            previewModal.classList.add('active');
            const c = previewCanvas.parentElement;
            previewRenderer.setSize(c.clientWidth, c.clientHeight);
            previewCamera.aspect = c.clientWidth / c.clientHeight;
            previewCamera.updateProjectionMatrix();
            renderLoop();
        }

        function closePreview() {
            previewModal.classList.remove('active');
            if (animId) { cancelAnimationFrame(animId); animId = null; }
        }

        previewCanvas.addEventListener('mousedown', e => { previewCtrl.drag = true; previewCtrl.lx = e.clientX; previewCtrl.ly = e.clientY; });
        previewCanvas.addEventListener('mousemove', e => {
            if (!previewCtrl.drag) return;
            previewCtrl.rx += (e.clientX - previewCtrl.lx) * 0.005;
            previewCtrl.ry += (e.clientY - previewCtrl.ly) * 0.005;
            previewCtrl.lx = e.clientX; previewCtrl.ly = e.clientY;
        });
        previewCanvas.addEventListener('mouseup', () => previewCtrl.drag = false);
        previewCanvas.addEventListener('mouseleave', () => previewCtrl.drag = false);
        previewCanvas.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
            previewCamera.position.z *= zoomFactor;
            previewCamera.position.z = Math.max(1, Math.min(10000, previewCamera.position.z));
        });

        // „Çø„ÉÉ„ÉÅÊìç‰ΩúÂØæÂøú
        let touchStartDist = 0;
        previewCanvas.addEventListener('touchstart', e => {
            e.preventDefault();
            if (e.touches.length === 1) {
                previewCtrl.drag = true;
                previewCtrl.lx = e.touches[0].clientX;
                previewCtrl.ly = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // „Éî„É≥„ÉÅ„Ç∫„Éº„É†ÈñãÂßã
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDist = Math.sqrt(dx * dx + dy * dy);
            }
        }, { passive: false });

        previewCanvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (e.touches.length === 1 && previewCtrl.drag) {
                // 1Êú¨Êåá: ÂõûËª¢
                previewCtrl.rx += (e.touches[0].clientX - previewCtrl.lx) * 0.005;
                previewCtrl.ry += (e.touches[0].clientY - previewCtrl.ly) * 0.005;
                previewCtrl.lx = e.touches[0].clientX;
                previewCtrl.ly = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // 2Êú¨Êåá: „Éî„É≥„ÉÅ„Ç∫„Éº„É†
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (touchStartDist > 0) {
                    const zoomFactor = touchStartDist / dist;
                    previewCamera.position.z *= zoomFactor;
                    previewCamera.position.z = Math.max(1, Math.min(10000, previewCamera.position.z));
                }
                touchStartDist = dist;
            }
        }, { passive: false });

        previewCanvas.addEventListener('touchend', e => {
            previewCtrl.drag = false;
            touchStartDist = 0;
        });

        previewBtn.addEventListener('click', openPreview);
        previewClose.addEventListener('click', closePreview);
        resetViewBtn.addEventListener('click', () => {
            previewCtrl.rx = 0.5;
            previewCtrl.ry = 0.5;
            if (previewMesh) {
                const vox = is3DModel ? current3DVoxels : currentBlocks;
                if (vox.length > 0) {
                    let mxX = -Infinity, mxY = -Infinity, mxZ = -Infinity, mnX = Infinity, mnY = Infinity, mnZ = Infinity;
                    for (const v of vox) {
                        const [x, y, z] = is3DModel ? v : [v[0], v[1], v[2]];
                        mnX = Math.min(mnX, x); mxX = Math.max(mxX, x);
                        mnY = Math.min(mnY, y); mxY = Math.max(mxY, y);
                        mnZ = Math.min(mnZ, z); mxZ = Math.max(mxZ, z);
                    }
                    const sz = Math.max(mxX - mnX, mxY - mnY, mxZ - mnZ) + 1;
                    previewCamera.position.z = sz * 1.5;
                } else {
                    previewCamera.position.z = 100;
                }
            }
        });
        toggleWireBtn.addEventListener('click', () => { wireMode = !wireMode; if (previewMesh?.material) previewMesh.material.wireframe = wireMode; toggleWireBtn.textContent = wireMode ? '„ÇΩ„É™„ÉÉ„ÉâË°®Á§∫' : '„ÉØ„Ç§„É§„ÉºË°®Á§∫'; });
        document.addEventListener('keydown', e => { if (e.key === 'Escape' && previewModal.classList.contains('active')) closePreview(); });

        const origProcess = processFile;
        processFile = async function (f) {
            await origProcess(f);
            previewBtn.disabled = !((is3DModel && current3DVoxels.length > 0) || (!is3DModel && currentBlocks.length > 0));
        };

        const origProcessFiles = processFiles;
        processFiles = async function (files) {
            await origProcessFiles(files);
            previewBtn.disabled = !((is3DModel && current3DVoxels.length > 0) || (!is3DModel && currentBlocks.length > 0));
        };

        log('Ê∫ñÂÇôÂÆå‰∫Ü');
    </script>
</body>

</html>